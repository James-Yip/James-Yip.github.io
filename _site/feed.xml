<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Yezh Blog</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 22 Nov 2017 16:36:52 +0000</pubDate>
    <lastBuildDate>Wed, 22 Nov 2017 16:36:52 +0000</lastBuildDate>
    <generator>Jekyll v3.6.2</generator>
    
      <item>
        <title>Go negroni-gzip源码分析</title>
        <description>&lt;h2 id=&quot;gzip概念&quot;&gt;gzip概念&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;GZIP最早由Jean-loup Gailly和Mark Adler创建，用于UNⅨ系统的文件压缩。我们在Linux中经常会用到后缀为.gz的文件，它们就是GZIP格式的。现今已经成为Internet 上使用非常普遍的一种数据压缩格式，或者说一种文件格式。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;gzip可用来对静态文件进行压缩, 以减少文件的传输时间和存储空间, 。大流量的WEB站点常常使用GZIP压缩技术来让减少响应时间, 提升用户的使用体验, 但同时压缩步骤的加入会增加服务器的负荷, 可以说是一种 “trade-off”。&lt;/p&gt;

&lt;p&gt;对于gzip, golang内置有&lt;code class=&quot;highlighter-rouge&quot;&gt;compress/gzip&lt;/code&gt;包可供使用。&lt;/p&gt;

&lt;p&gt;此处主要对用于 &lt;a href=&quot;https://github.com/urfave/negroni&quot;&gt;Negroni&lt;/a&gt; 组件的&lt;a href=&quot;https://github.com/phyber/negroni-gzip&quot;&gt;gzip&lt;/a&gt;包进行源码分析。&lt;/p&gt;

&lt;p&gt;该gzip包内部使用了go提供的 &lt;code class=&quot;highlighter-rouge&quot;&gt;compress/gzip&lt;/code&gt; 包,  具体实现并不复杂。&lt;/p&gt;

&lt;h2 id=&quot;用法&quot;&gt;用法&lt;/h2&gt;
&lt;p&gt;下面为开发者提供的一个简单样例:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;net/http&quot;&lt;/span&gt;

    &lt;span class=&quot;s2&quot;&gt;&quot;github.com/urfave/negroni&quot;&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;github.com/phyber/negroni-gzip/gzip&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mux&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewServeMux&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mux&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HandleFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    	  &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Welcome to the home page!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;negroni&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Classic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Use&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gzip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Gzip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gzip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DefaultCompression&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UseHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mux&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;:3000&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;该样例使用了negroni, 并在其中启用了gzip中间件, 该中间件在 request 预处理 或 response 后处理中对文件进行压缩或解压。&lt;/p&gt;

&lt;h2 id=&quot;negroni-gzip-源码分析&quot;&gt;negroni-gzip 源码分析&lt;/h2&gt;

&lt;p&gt;此处对 negroni-gzip 源码的分析分为两部分:&lt;/p&gt;

&lt;p&gt;对其中定义的结构体和常量的解释, 以及对函数和方法的分析。&lt;/p&gt;

&lt;h3 id=&quot;结构体--常量&quot;&gt;结构体 &amp;amp; 常量&lt;/h3&gt;

&lt;h4 id=&quot;gzipresponsewriter结构体&quot;&gt;gzipResponseWriter结构体&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type gzipResponseWriter struct {
	w *gzip.Writer
	negroni.ResponseWriter
	wroteHeader bool
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;结构体成员&lt;/th&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;解释&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;w&lt;/td&gt;
      &lt;td&gt;*gzip.Writer&lt;/td&gt;
      &lt;td&gt;用于写数据&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;negroni.ResponseWriter&lt;/td&gt;
      &lt;td&gt;匿名成员, gzipResponseWriter结构体可直接访问该接口的方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;wroteHeader&lt;/td&gt;
      &lt;td&gt;bool&lt;/td&gt;
      &lt;td&gt;记录是否已写了header, 避免重复写header&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;handler结构体&quot;&gt;handler结构体&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type handler struct {
	pool sync.Pool
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;handler结构体中只有一个成员 pool (类型为sync包中定义的&lt;a href=&quot;https://go-zh.org/pkg/sync/#Pool&quot;&gt;Pool&lt;/a&gt;结构体)&lt;/p&gt;

&lt;p&gt;pool 的作用是用于缓存那些已经分配了内存但是暂时还未使用的数据, 以供后续使用。(同时pool能够保证多个goroutines同时使用它时的安全性)&lt;/p&gt;

&lt;p&gt;其Put方法可以将一个任意类型的数据放入pool中;&lt;/p&gt;

&lt;p&gt;还有一个Get方法则可以从pool中随机选择一个item, 将其从pool中移除, 并返回给调用者。&lt;/p&gt;

&lt;h4 id=&quot;常量&quot;&gt;常量&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const (
	encodingGzip = &quot;gzip&quot;

	headerAcceptEncoding  = &quot;Accept-Encoding&quot;
	headerContentEncoding = &quot;Content-Encoding&quot;
	headerContentLength   = &quot;Content-Length&quot;
	headerContentType     = &quot;Content-Type&quot;
	headerVary            = &quot;Vary&quot;
	headerSecWebSocketKey = &quot;Sec-WebSocket-Key&quot;

	BestCompression    = gzip.BestCompression
	BestSpeed          = gzip.BestSpeed
	DefaultCompression = gzip.DefaultCompression
	NoCompression      = gzip.NoCompression
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注: 以上常量实际上是开发者直接从 &lt;code class=&quot;highlighter-rouge&quot;&gt;compress/gzip&lt;/code&gt; 包中复制过来的。&lt;/p&gt;

&lt;h3 id=&quot;gzip函数&quot;&gt;Gzip函数&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Gzip returns a handler which will handle the Gzip compression in ServeHTTP.
// Valid values for level are identical to those in the compress/gzip package.
func Gzip(level int) *handler {
	h := &amp;amp;handler{}
	h.pool.New = func() interface{} {
		gz, err := gzip.NewWriterLevel(ioutil.Discard, level)
		if err != nil {
			panic(err)
		}
		return gz
	}
	return h
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Gzip函数初始化了一个空handler结构体
并对其成员赋初值,
然后返回该handler h, 传给negroni的Use方法。&lt;/p&gt;

&lt;p&gt;注: 由于handler结构体类型定义了其ServeHTTP方法(该方法下面会进行分析), 所以handler实现了negroni.Handler接口(negroni的Use方法所需的传入参数), 可以赋值给该接口。&lt;/p&gt;

&lt;h3 id=&quot;handlerservehttp方法&quot;&gt;handler.ServeHTTP方法&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ServeHTTP wraps the http.ResponseWriter with a gzip.Writer.
func (h *handler) ServeHTTP(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) {
	// Skip compression if the client doesn't accept gzip encoding.
	if !strings.Contains(r.Header.Get(headerAcceptEncoding), encodingGzip) {juhao
		next(w, r)
		return
	}

	// Skip compression if client attempt WebSocket connection
	if len(r.Header.Get(headerSecWebSocketKey)) &amp;gt; 0 {
		next(w, r)
		return
	}

	// Retrieve gzip writer from the pool. Reset it to use the ResponseWriter.
	// This allows us to re-use an already allocated buffer rather than
	// allocating a new buffer for every request.
	// We defer g.pool.Put here so that the gz writer is returned to the
	// pool if any thing after here fails for some reason (functions in
	// next could potentially panic, etc)
	gz := h.pool.Get().(*gzip.Writer)
	defer h.pool.Put(gz)
	gz.Reset(w)juhao

	// Wrap the original http.ResponseWriter with negroni.ResponseWriter
	// and create the gzipResponseWriter.
	nrw := negroni.NewResponseWriter(w)
	grw := gzipResponseWriter{gz, nrw, false}

	// Call the next handler supplying the gzipResponseWriter instead of
	// the original.
	next(&amp;amp;grw, r)

	// Delete the content length after we know we have been written to.
	grw.Header().Del(headerContentLength)

	gz.Close()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;handler.ServeHTTP方法 的具体实现其实上述代码的注释中已经解释得很清晰了:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;对于某些情况(客户端不支持gzip编码 或 客户端正尝试建立socket连接)跳过压缩步骤, 直接进入下一个中间件处理;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;从pool中提取出 gzip writer, 并将其重置;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;调用 negroni.NewResponseWriter 方法 得到一个封装了http.ResponseWriter 以及 其它一些方法 的 negroni.ResponseWriter接口;(具体可见&lt;a href=&quot;https://github.com/urfave/negroni/blob/master/response_writer.go&quot;&gt;negroni相应源码&lt;/a&gt;)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将从第二第三步中得到的 gzip writer 和 negroni.ResponseWriter 作为初值 初始化创建一个 gzipResponseWriter结构体实例, 并将其传给下一个中间件;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;收尾工作。将gzipResponseWriter Header中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;headerContentLength&lt;/code&gt; 字段删除 并 关闭 gzip writer&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;gzipresponsewriterwriteheader方法&quot;&gt;gzipResponseWriter.WriteHeader方法&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Check whether underlying response is already pre-encoded and disable
// gzipWriter before the body gets written, otherwise encoding headers
func (grw *gzipResponseWriter) WriteHeader(code int) {
	headers := grw.ResponseWriter.Header()
	if headers.Get(headerContentEncoding) == &quot;&quot; {
		headers.Set(hegoaderContentEncoding, encodingGzip)
		headers.Add(headerVary, headerAcceptEncoding)
	} else {
		grw.w.Reset(ioutil.Discard)
		grw.w = nil
	}
	grw.ResponseWriter.WriteHeader(code)
	grw.wroteHeader = true
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如注释中所说, 该方法首先会检查 response 是否已经进行了编码,&lt;/p&gt;

&lt;p&gt;如果是, 则不会再进行gzip编码(将gzipWriter无效化并将gzipResponseWriter中类型为*gzip.Writer的成员w置空);&lt;/p&gt;

&lt;p&gt;否则, 则会将header中的Content-Encoding字段 设为 “gzip”, 表示使用gzip编码。&lt;/p&gt;

&lt;p&gt;最后, 无论是否使用gzip编码, 都会调用 http.ResponseWriter.WriteHeader 方法 进行基本的 Header 写操作(基于传入的返回码code)&lt;/p&gt;

&lt;p&gt;注意: 由于gzipResponseWriter结构体中有一个匿名成员negroni.ResponseWriter, 而该成员(接口)中又有匿名成员http.ResponseWriter(其有一个WriteHeader方法),
所以代码中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;grw.ResponseWriter.WriteHeader(code)&lt;/code&gt;
其实还可以简化为 &lt;code class=&quot;highlighter-rouge&quot;&gt;grw.WriteHeader(code)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;gzipresponsewriterwrite方法&quot;&gt;gzipResponseWriter.Write方法&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Write writes bytes to the gzip.Writer. It will also set the Content-Type
// header using the net/http library content type detection if the Content-Type
// header was not set yet.
func (grw *gzipResponseWriter) Write(b []byte) (int, error) {
	if !grw.wroteHeader {
		grw.WriteHeader(http.StatusOK)
	}
	if grw.w == nil {
		return grw.ResponseWriter.Write(b)
	}
	if len(grw.Header().Get(headerContentType)) == 0 {
		grw.Header().Set(headerContentType, http.DetectContentType(b))
	}
	return grw.w.Write(b)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同样, 如注释所说, 该方法 写数据到gzip.Writer。
另外, 如果header的Content-Type字段还未设置, 则会通过调用 net/http包中的DetectContentType函数来自动确定Content-Type, 并将其设置到header的Content-Type字段中。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;至此, 对negroni-gzip 的源码分析就基本完成啦。&lt;/p&gt;
</description>
        <pubDate>Tue, 21 Nov 2017 23:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/11/21/go-negroni-gzip/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/11/21/go-negroni-gzip/</guid>
        
        <category>go</category>
        
        
      </item>
    
      <item>
        <title>Golang http包源码分析</title>
        <description>&lt;h2 id=&quot;搭建简单web服务器&quot;&gt;搭建简单web服务器&lt;/h2&gt;
&lt;p&gt;利用 Go 内置的 net/http 包, 可以快速搭建一个简单的web服务器:&lt;/p&gt;

&lt;p&gt;main.go&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;net/http&quot;&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;strings&quot;&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;log&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handleRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;your&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;implementation&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blabla&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;route&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HandleFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handleRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Listening at port 9090...&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listen&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;9090&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serve&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requests&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ListenAndServe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;:9090&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;!= nil {
&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fatal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ListenAndServe: &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上面代码的运行结果就不贴出来了(因为也没什么输出hhh)&lt;/p&gt;

&lt;p&gt;接下来将以上面的程序为例, 具体分析http包在内部是如何实现的。&lt;/p&gt;

&lt;h2 id=&quot;http包内部实现&quot;&gt;http包内部实现&lt;/h2&gt;
&lt;p&gt;在上面给出的代码中, 实际上关键的函数就两个:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http.HandleFunc(&quot;/&quot;, handleRequest)

http.ListenAndServe(&quot;:9090&quot;, nil)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其功能正如注释中所说, 注册处理函数, 监听端口, 提供服务(当客户端 request url 的路径为 &lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt; 时, 调用handleRequest函数)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;为了了解http包的内部实现, 我们需要知道这两个函数内部究竟做了什么。&lt;/p&gt;

&lt;p&gt;具体源码可在当前 &lt;code class=&quot;highlighter-rouge&quot;&gt;$GOROOT&lt;/code&gt; 下的 src 目录下找到,
以我的电脑为例(Ubuntu 16.04), 源码的具体路径为:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/lib/go-1.6/src/net/http/server.go&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;注意事项:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;提供的源码路径仅供参考, 可能以后有了新版本的go, 文件目录结构又变了, 但一般内置的库都是放在 &lt;code class=&quot;highlighter-rouge&quot;&gt;$GOROOT&lt;/code&gt; 路径下的;&lt;/li&gt;
  &lt;li&gt;http目录下有两个同名文件server.go, 我们要研究的源码在 package 为 http 的 server.go 文件中 (另一个的 package 为 httptest)。&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;内置结构体--类型-定义&quot;&gt;内置结构体 &amp;amp; 类型 定义&lt;/h3&gt;
&lt;p&gt;在对函数进行分析前, 先列出其中出现的一些结构体以及接口等的类型定义:&lt;/p&gt;

&lt;h4 id=&quot;handler-接口&quot;&gt;Handler 接口&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Handler interface {
	ServeHTTP(ResponseWriter, *Request)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;该接口只定义了一个方法, 也就是说, 只要一个类型实现了这个 &lt;code class=&quot;highlighter-rouge&quot;&gt;ServeHTTP&lt;/code&gt; 方法, 我们就可以把该类型的变量直接赋值给 Handler接口, 这在后面的具体内部实现中多次出现, 很有用。&lt;/p&gt;

&lt;h4 id=&quot;servemux-结构体&quot;&gt;ServeMux 结构体&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type ServeMux struct {
	mu    sync.RWMutex
	m     map[string]muxEntry
	hosts bool // whether any patterns contain hostnames
}

type muxEntry struct {
	explicit bool
	h        Handler
	pattern  string
}

// NewServeMux allocates and returns a new ServeMux.
func NewServeMux() *ServeMux { return &amp;amp;ServeMux{m: make(map[string]muxEntry)} }

var DefaultServeMux = NewServeMux()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;ServeMux结构说明
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ServeMux
     mu    : 用于并发控制的锁
     m     : 存有muxEntry的map (key 为 pattern)
     hosts : 用于判断模式中是否包含主机名
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;muxEntry结构说明
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // 每一个 muxEntry 对应一个处理函数
 muxEntry
     explicit : 当为 true 时表明该 pattern 已注册, 防止再次有相同 pattern 进行注册
     h        : 处理函数 (如本例中的 handleRequest 函数)
     pattern  : 模式 (如本例中的 &quot;/&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;DefaultServeMux 为默认的 &lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP request multiplexer&lt;/code&gt;, 当服务端程序未指明特定的 multiplexer 时, 就会使用这个http包中声明好的 ServeMux 实例。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于 ServeMux 结构体, http包中的注释如下所示:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;ServeMux is an HTTP request multiplexer.
 It matches the URL of each incoming request against a list of registered
 patterns and calls the handler for the pattern that
 most closely matches the URL.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单来说, ServeMux这个结构体主要存储了不同 pattern 对应的逻辑处理函数 (存储于一个map中)。&lt;/p&gt;

&lt;p&gt;对于每一个请求, 将其 url 与已注册 pattern 匹配, 若匹配成功, 则调用相应的处理函数。&lt;/p&gt;

&lt;h4 id=&quot;handlerfunc类型&quot;&gt;HandlerFunc类型&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(w, r).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
	f(w, r)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;HandlerFunc类型实现了ServeHTTP方法, 因此可以赋值给前面提到的Handler接口&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 区分 HandlerFunc(类型) 和 HandleFunc(函数)&lt;/p&gt;

&lt;h4 id=&quot;serverhandler结构体&quot;&gt;serverHandler结构体&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type serverHandler struct {
    srv *Server
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;该结构体类型也实现了ServeHTTP方法, 也可以赋值给Handler接口&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;下面进行具体的源码分析:&lt;/p&gt;

&lt;h3 id=&quot;httphandlefunc&quot;&gt;http.HandleFunc&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// HandleFunc registers the handler function for the given pattern
// in the DefaultServeMux.
// The documentation for ServeMux explains how patterns are matched.
func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
	DefaultServeMux.HandleFunc(pattern, handler)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;http.HandleFunc 中,&lt;/p&gt;

&lt;p&gt;调用了ServeMux.HandleFunc方法 (receiver 为 DefaultServeMux), 传入参数 “/” 和 handleRequest 函数&lt;/p&gt;

&lt;h3 id=&quot;servemuxhandlefunc&quot;&gt;ServeMux.HandleFunc&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// HandleFunc registers the handler function for the given pattern.
func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
	mux.Handle(pattern, HandlerFunc(handler))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;ServeMux.HandleFunc中,&lt;/p&gt;

&lt;p&gt;将传入的handler (即handleRequest函数) 强制类型转换为 HandlerFunc 类型 (如前面提到的, 该类型实现了Handler接口, 可以赋值给Handler接口)&lt;/p&gt;

&lt;p&gt;然后, 调用了 ServeMux.Handle 方法 (receiver 为 DefaultServeMux), 传入参数”/”和已变为 HandlerFunc 类型的 handleRequest 函数&lt;/p&gt;

&lt;h3 id=&quot;servemuxhandle&quot;&gt;ServeMux.Handle&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Handle registers the handler for the given pattern.
// If a handler already exists for pattern, Handle panics.
func (mux *ServeMux) Handle(pattern string, handler Handler) {
	mux.mu.Lock()
	defer mux.mu.Unlock()

	if pattern == &quot;&quot; {
		panic(&quot;http: invalid pattern &quot; + pattern)
	}
	if handler == nil {
		panic(&quot;http: nil handler&quot;)
	}
	if mux.m[pattern].explicit {
		panic(&quot;http: multiple registrations for &quot; + pattern)
	}

	mux.m[pattern] = muxEntry{explicit: true, h: handler, pattern: pattern}

	if pattern[0] != '/' {
		mux.hosts = true
	}

	// Helpful behavior:
	// If pattern is /tree/, insert an implicit permanent redirect for /tree.
	// It can be overridden by an explicit registration.
	n := len(pattern)
	if n &amp;gt; 0 &amp;amp;&amp;amp; pattern[n-1] == '/' &amp;amp;&amp;amp; !mux.m[pattern[0:n-1]].explicit {
		// If pattern contains a host name, strip it and use remaining
		// path for redirect.
		path := pattern
		if pattern[0] != '/' {
			// In pattern, at least the last character is a '/', so
			// strings.Index can't be -1.
			path = pattern[strings.Index(pattern, &quot;/&quot;):]
		}
		url := &amp;amp;url.URL{Path: path}
		mux.m[pattern[0:n-1]] = muxEntry{h: RedirectHandler(url.String(), StatusMovedPermanently), pattern: pattern}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ServeMux.Handle中,&lt;/p&gt;

&lt;p&gt;前面主要进行了输入参数(pattern 和 handler)的合法性检测&lt;/p&gt;

&lt;p&gt;我们重点关注这一行代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mux.m[pattern] = muxEntry{explicit: true, h: handler, pattern: pattern}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这行代码声明并初始化了一个muxEntry结构体, 并根据其 pattern 将其放到 DefaultServeMux 的 map &lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt; 中, 实现了相应路由处理函数的注册&lt;/p&gt;

&lt;p&gt;(注: 将 explicit 设为 true 表明该 pattern 已注册, 当有相同 pattern 进行注册时, 会调用panic函数)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;至此, main中第一个关键函数调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;http.HandleFunc(&quot;/&quot;, HandleRequest)&lt;/code&gt; 就分析完毕了, 实际上就是把 pattern(“/”) 和 handler(HandleRequest) 存入 DefaultServeMux 的 map 中&lt;/p&gt;

&lt;p&gt;下面对第二个关键调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;http.ListenAndServe(&quot;:9090&quot;, nil)&lt;/code&gt; 进行分析&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;httplistenandserve&quot;&gt;http.ListenAndServe&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ListenAndServe always returns a non-nil error.
func ListenAndServe(addr string, handler Handler) error {
	server := &amp;amp;Server{Addr: addr, Handler: handler}
	return server.ListenAndServe()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;http.ListenAndServe中,&lt;/p&gt;

&lt;p&gt;首先用传入的参数 (“:9090” &amp;amp; nil) 初始化了一个Server结构体&lt;/p&gt;

&lt;p&gt;然后调用了Server.ListenAndServe方法 (receiver 为刚创建的server)&lt;/p&gt;

&lt;h3 id=&quot;serverlistenandserve&quot;&gt;Server.ListenAndServe&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ListenAndServe listens on the TCP network address srv.Addr and then
// calls Serve to handle requests on incoming connections.
// Accepted connections are configured to enable TCP keep-alives.
// If srv.Addr is blank, &quot;:http&quot; is used.
// ListenAndServe always returns a non-nil error.
func (srv *Server) ListenAndServe() error {
	addr := srv.Addr
	if addr == &quot;&quot; {
		addr = &quot;:http&quot;
	}
	ln, err := net.Listen(&quot;tcp&quot;, addr)
	if err != nil {
		return err
	}
	return srv.Serve(tcpKeepAliveListener{ln.(*net.TCPListener)})
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Server.ListenAndServe中,&lt;/p&gt;

&lt;p&gt;对给定的端口进行监听 (基于TCP协议)&lt;/p&gt;

&lt;p&gt;并调用Server.Serve函数(receiver 为之前创建的实例 server), 传入参数 ln (调用listen函数后返回的Listener接口)&lt;/p&gt;

&lt;h3 id=&quot;serverserve&quot;&gt;Server.Serve&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Serve accepts incoming connections on the Listener l, creating a
// new service goroutine for each. The service goroutines read requests and
// then call srv.Handler to reply to them.
// Serve always returns a non-nil error.
func (srv *Server) Serve(l net.Listener) error {
	defer l.Close()
	if fn := testHookServerServe; fn != nil {
		fn(srv, l)
	}
	var tempDelay time.Duration // how long to sleep on accept failure
	if err := srv.setupHTTP2(); err != nil {
		return err
	}
	for {
		rw, e := l.Accept()
		if e != nil {
			if ne, ok := e.(net.Error); ok &amp;amp;&amp;amp; ne.Temporary() {
				if tempDelay == 0 {
					tempDelay = 5 * time.Millisecond
				} else {
					tempDelay *= 2
				}
				if max := 1 * time.Second; tempDelay &amp;gt; max {
					tempDelay = max
				}
				srv.logf(&quot;http: Accept error: %v; retrying in %v&quot;, e, tempDelay)
				time.Sleep(tempDelay)
				continue
			}
			return e
		}
		tempDelay = 0
		c := srv.newConn(rw)
		c.setState(c.rwc, StateNew) // before Serve can return
		go c.serve()
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Server.Serve中,
可将上述代码简化为:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for {
    rw, e := l.Accept()
    ...
    c, err := srv.newConn(rw)
    ...
    go c.serve()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Listener 接收请求&lt;/p&gt;

&lt;p&gt;当接收到请求时, 建立新连接&lt;/p&gt;

&lt;p&gt;并用 goroutine 运行 conn.serve (receiver 为 建立新连接后返回的 Conn指针 &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;)&lt;/p&gt;

&lt;h3 id=&quot;connserve&quot;&gt;conn.serve&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Serve a new connection.
func (c *conn) serve() {
	c.remoteAddr = c.rwc.RemoteAddr().String()
	defer func() {
		if err := recover(); err != nil {
			const size = 64 &amp;lt;&amp;lt; 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			c.server.logf(&quot;http: panic serving %v: %v\n%s&quot;, c.remoteAddr, err, buf)
		}
		if !c.hijacked() {
			c.close()
			c.setState(c.rwc, StateClosed)
		}
	}()

	if tlsConn, ok := c.rwc.(*tls.Conn); ok {
		if d := c.server.ReadTimeout; d != 0 {
			c.rwc.SetReadDeadline(time.Now().Add(d))
		}
		if d := c.server.WriteTimeout; d != 0 {
			c.rwc.SetWriteDeadline(time.Now().Add(d))
		}
		if err := tlsConn.Handshake(); err != nil {
			c.server.logf(&quot;http: TLS handshake error from %s: %v&quot;, c.rwc.RemoteAddr(), err)
			return
		}
		c.tlsState = new(tls.ConnectionState)
		*c.tlsState = tlsConn.ConnectionState()
		if proto := c.tlsState.NegotiatedProtocol; validNPN(proto) {
			if fn := c.server.TLSNextProto[proto]; fn != nil {
				h := initNPNRequest{tlsConn, serverHandler{c.server}}
				fn(c.server, tlsConn, h)
			}
			return
		}
	}

	c.r = &amp;amp;connReader{r: c.rwc}
	c.bufr = newBufioReader(c.r)
	c.bufw = newBufioWriterSize(checkConnErrorWriter{c}, 4&amp;lt;&amp;lt;10)

	for {
		w, err := c.readRequest()
		if c.r.remain != c.server.initialReadLimitSize() {
			// If we read any bytes off the wire, we're active.
			c.setState(c.rwc, StateActive)
		}
		if err != nil {
			if err == errTooLarge {
				// Their HTTP client may or may not be
				// able to read this if we're
				// responding to them and hanging up
				// while they're still writing their
				// request.  Undefined behavior.
				io.WriteString(c.rwc, &quot;HTTP/1.1 431 Request Header Fields Too Large\r\nContent-Type: text/plain\r\nConnection: close\r\n\r\n431 Request Header Fields Too Large&quot;)
				c.closeWriteAndWait()
				return
			}
			if err == io.EOF {
				return // don't reply
			}
			if neterr, ok := err.(net.Error); ok &amp;amp;&amp;amp; neterr.Timeout() {
				return // don't reply
			}
			var publicErr string
			if v, ok := err.(badRequestError); ok {
				publicErr = &quot;: &quot; + string(v)
			}
			io.WriteString(c.rwc, &quot;HTTP/1.1 400 Bad Request\r\nContent-Type: text/plain\r\nConnection: close\r\n\r\n400 Bad Request&quot;+publicErr)
			return
		}

		// Expect 100 Continue support
		req := w.req
		if req.expectsContinue() {
			if req.ProtoAtLeast(1, 1) &amp;amp;&amp;amp; req.ContentLength != 0 {
				// Wrap the Body reader with one that replies on the connection
				req.Body = &amp;amp;expectContinueReader{readCloser: req.Body, resp: w}
			}
		} else if req.Header.get(&quot;Expect&quot;) != &quot;&quot; {
			w.sendExpectationFailed()
			return
		}

		// HTTP cannot have multiple simultaneous active requests.[*]
		// Until the server replies to this request, it can't read another,
		// so we might as well run the handler in this goroutine.
		// [*] Not strictly true: HTTP pipelining.  We could let them all process
		// in parallel even if their responses need to be serialized.
		serverHandler{c.server}.ServeHTTP(w, w.req)
		if c.hijacked() {
			return
		}
		w.finishRequest()
		if !w.shouldReuseConnection() {
			if w.requestBodyLimitHit || w.closedRequestBodyEarly() {
				c.closeWriteAndWait()
			}
			return
		}
		c.setState(c.rwc, StateIdle)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;类似的, 我们重点关注for循环部分并将其简化为:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for{
  w, err := c.readRequest()
  ...
  serverHandler{c.server}.ServeHTTP(w, w.req)
  ...
  w.finishRequest()
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对于同一个连接, 循环地执行读取请求, 处理请求, 完成请求三个操作&lt;/p&gt;

&lt;p&gt;对于其中三个操作, 我们重点看处理请求部分&lt;/p&gt;

&lt;p&gt;即: &lt;code class=&quot;highlighter-rouge&quot;&gt;serverHandler{c.server}.ServeHTTP(w, w.req)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;该语句调用了 serverHandler.ServeHTTP 方法&lt;/p&gt;

&lt;h3 id=&quot;serverhandlerservehttp&quot;&gt;serverHandler.ServeHTTP&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {
    handler := sh.srv.Handler
    if handler == nil {
        handler = DefaultServeMux
    }
    if req.RequestURI == &quot;*&quot; &amp;amp;&amp;amp; req.Method == &quot;OPTIONS&quot; {
        handler = globalOptionsHandler{}
    }
    handler.ServeHTTP(rw, req)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;serverHandler.ServeHTTP中,&lt;/p&gt;

&lt;p&gt;根据我们在一开始调用http.ListenAndServe函数时传入的handler参数来确定 handler (ServeMux结构体类型), 若传入为 &lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;, 则 handler 为默认的 DefaultServeMux,
然后调用 ServeMux.ServeHTTP 方法 (receiver 为handler, 本例中即为 DefaultServeMux)&lt;/p&gt;

&lt;h3 id=&quot;servemuxservehttp&quot;&gt;ServeMux.ServeHTTP&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ServeHTTP dispatches the request to the handler whose
// pattern most closely matches the request URL.
func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {
	if r.RequestURI == &quot;*&quot; {
		if r.ProtoAtLeast(1, 1) {
			w.Header().Set(&quot;Connection&quot;, &quot;close&quot;)
		}
		w.WriteHeader(StatusBadRequest)
		return
	}
	h, _ := mux.Handler(r)
	h.ServeHTTP(w, r)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ServeMux.ServeHTTP中,&lt;/p&gt;

&lt;p&gt;我们主要关注下面两行代码:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;h, _ := mux.Handler(r)
h.ServeHTTP(w, r)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;第一行代码 调用了 ServeMux.Handler 方法 (此处 receiver 为 DefaultServeMux), 传入请求 &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt;, 返回相应的逻辑处理函数 (HandlerFunc 类型)&lt;/p&gt;

&lt;p&gt;第二行代码 则是执行返回的 handler 的 ServeHTTP 方法(即 &lt;code class=&quot;highlighter-rouge&quot;&gt;HandlerFunc.ServeHTTP&lt;/code&gt;, 该方法在前面的 &lt;code class=&quot;highlighter-rouge&quot;&gt;内置结构体 &amp;amp; 类型 定义&lt;/code&gt; 那节给出, 实际上就是执行了 receiver 本身)&lt;/p&gt;

&lt;p&gt;至于 ServeMux.Handler, 其具体实现如下所示&lt;/p&gt;

&lt;h3 id=&quot;servemuxhandler&quot;&gt;ServeMux.Handler&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) {
	if r.Method != &quot;CONNECT&quot; {
		if p := cleanPath(r.URL.Path); p != r.URL.Path {
			_, pattern = mux.handler(r.Host, p)
			url := *r.URL
			url.Path = p
			return RedirectHandler(url.String(), StatusMovedPermanently), pattern
		}
	}

	return mux.handler(r.Host, r.URL.Path)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;ServeMux.Handler中,&lt;/p&gt;

&lt;p&gt;调用了 ServeMux.handler 方法(receiver 为 DefaultServeMux), 传入请求 &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; 的 主机名 &amp;amp; URL的路径部分&lt;/p&gt;

&lt;h3 id=&quot;servemuxhandler-1&quot;&gt;ServeMux.handler&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (mux *ServeMux) handler(host, path string) (h Handler, pattern string) {
    mux.mu.RLock()
    defer mux.mu.RUnlock()

    // Host-specific pattern takes precedence over generic ones
    if mux.hosts {
        h, pattern = mux.match(host + path)
    }
    if h == nil {
        h, pattern = mux.match(path)
    }
    if h == nil {
        h, pattern = NotFoundHandler(), &quot;&quot;
    }
    return
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;ServeMux.Handler中,&lt;/p&gt;

&lt;p&gt;调用 ServeMux.match 方法, 传入相应的请求路径, 返回 匹配的 handler 和 pattern&lt;/p&gt;

&lt;h3 id=&quot;servemuxmatch&quot;&gt;ServeMux.match&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (mux *ServeMux) match(path string) (h Handler, pattern string) {
	var n = 0
	for k, v := range mux.m {
		if !pathMatch(k, path) {
			continue
		}
		if h == nil || len(k) &amp;gt; n {
			n = len(k)
			h = v.h
			pattern = v.pattern
		}
	}
	return
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ServeMux.match中,&lt;/p&gt;

&lt;p&gt;遍历 receiver (此处为 DefaultServeMux) 的 map, 对于输入的路径, 找到能与之相匹配的已注册pattern, 返回 相应的 handler 和 pattern&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;最后, 重新整理一下主要的函数调用过程:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;main
├── http.HandleFunc
|   └── ServeMux.HandleFunc
|       └── ServeMux.Handle
└── http.ListenAndServe
    └── Server.ListenAndServe
        ├── net.Listen
        └── Server.Serve
            ├── Listener.Accept
            ├── Server.newConn
            └── conn.serve
                ├── conn.readRequest
                ├── serverHandler.ServeHTTP
                |   └── ServeMux.ServeHTTP
                |       ├── ServeMux.Handler
                |       |   └── ServeMux.handler
                |       |       └── ServeMux.match
                |       └── HandlerFunc.ServeHTTP
                └── response.finishRequest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;至此, 对于实现web服务器搭建部分的http源码就基本分析完啦。&lt;/p&gt;

&lt;p&gt;注: 代码高亮暂时存在问题, 等以后解决了再更新。(貌似暂不支持golang语法高亮)&lt;/p&gt;
</description>
        <pubDate>Thu, 16 Nov 2017 23:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/11/16/go-http-src-analysis/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/11/16/go-http-src-analysis/</guid>
        
        <category>go</category>
        
        <category>http</category>
        
        
      </item>
    
      <item>
        <title>Welcome to Yezh Blog</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“This is the beginning.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;Yezh 的 blog 开通啦!&lt;/p&gt;

&lt;p&gt;现在开始, 我将不定期更新我的博客。&lt;/p&gt;

&lt;p&gt;内容主要为技术帖。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;

&lt;p&gt;一开始打算直接弄一个 CSDN 博客, 但是在注册时用户名老是重复, 不重复的又不好记, 于是就暂时搁置了。&lt;/p&gt;

&lt;p&gt;后来发现 &lt;code class=&quot;highlighter-rouge&quot;&gt;Github Pages&lt;/code&gt; 可以免费托管静态内容, 了解后发现并不难, 于是就开始正式搭建我的博客啦。&lt;/p&gt;

&lt;p&gt;我采用的技术方案为: &lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt; + &lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其优点有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可直接采用 &lt;strong&gt;Markdown&lt;/strong&gt; 书写&lt;/li&gt;
  &lt;li&gt;采用 Git workflow ，&lt;strong&gt;Git Commit 即 Blog Post&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;免费无限空间 (不用自己折腾主机)&lt;/li&gt;
  &lt;li&gt;可自定义域名 (只需简单改改 DNS, 加个 CNAME 就好了)&lt;/li&gt;
  &lt;li&gt;Jekyll 自定制实现容易&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;博客搭建的过程主要参照了 &lt;a href=&quot;http://qiubaiying.top/2017/02/06/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/&quot;&gt;利用 GitHub Pages 快速搭建博客&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;致谢&quot;&gt;致谢&lt;/h2&gt;

&lt;p&gt;最后, 感谢 &lt;a href=&quot;https://github.com/huxpro&quot;&gt;Huxpro&lt;/a&gt; 提供的博客模板 和 &lt;a href=&quot;https://github.com/qiubaiying&quot;&gt;qiubaiying&lt;/a&gt; 的博客搭建教程。&lt;/p&gt;
</description>
        <pubDate>Wed, 15 Nov 2017 09:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/11/15/hello-blog/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/11/15/hello-blog/</guid>
        
        <category>blog</category>
        
        
      </item>
    
  </channel>
</rss>
