<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Yezh Blog</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 17 Nov 2017 08:27:17 +0000</pubDate>
    <lastBuildDate>Fri, 17 Nov 2017 08:27:17 +0000</lastBuildDate>
    <generator>Jekyll v3.6.2</generator>
    
      <item>
        <title>Golang http包源码分析</title>
        <description>&lt;h2 id=&quot;搭建简单web服务器&quot;&gt;搭建简单web服务器&lt;/h2&gt;
&lt;p&gt;利用 Go 内置的 net/http 包, 可以快速搭建一个简单的web服务器:&lt;/p&gt;

&lt;p&gt;main.go&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;net/http&quot;&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;strings&quot;&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;log&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handleRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;your&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;implementation&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blabla&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;route&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HandleFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handleRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Listening at port 9090...&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listen&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;9090&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serve&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requests&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ListenAndServe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;:9090&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;!= nil {
&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fatal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ListenAndServe: &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上面代码的运行结果就不贴出来了(因为也没什么输出hhh)&lt;/p&gt;

&lt;p&gt;接下来将以上面的程序为例, 具体分析http包在内部是如何实现的。&lt;/p&gt;

&lt;h2 id=&quot;http包内部实现&quot;&gt;http包内部实现&lt;/h2&gt;
&lt;p&gt;在上面给出的代码中, 实际上关键的函数就两个:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http.HandleFunc(&quot;/&quot;, handleRequest)

http.ListenAndServe(&quot;:9090&quot;, nil)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其功能正如注释中所说, 注册处理函数, 监听端口, 提供服务(当客户端 request url 的路径为 &lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt; 时, 调用handleRequest函数)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;为了了解http包的内部实现, 我们需要知道这两个函数内部究竟做了什么。&lt;/p&gt;

&lt;p&gt;具体源码可在当前 &lt;code class=&quot;highlighter-rouge&quot;&gt;$GOROOT&lt;/code&gt; 下的 src 目录下找到,
以我的电脑为例(Ubuntu 16.04), 源码的具体路径为:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/lib/go-1.6/src/net/http/server.go&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;注意事项:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;提供的源码路径仅供参考, 可能以后有了新版本的go, 文件目录结构又变了, 但一般内置的库都是放在 &lt;code class=&quot;highlighter-rouge&quot;&gt;$GOROOT&lt;/code&gt; 路径下的;&lt;/li&gt;
  &lt;li&gt;http目录下有两个同名文件server.go, 我们要研究的源码在 package 为 http 的 server.go 文件中 (另一个的 package 为 httptest)。&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;内置结构体--类型-定义&quot;&gt;内置结构体 &amp;amp; 类型 定义&lt;/h3&gt;
&lt;p&gt;在对函数进行分析前, 先列出其中出现的一些结构体以及接口等的类型定义:&lt;/p&gt;

&lt;h4 id=&quot;handler-接口&quot;&gt;Handler 接口&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Handler interface {
	ServeHTTP(ResponseWriter, *Request)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;该接口只定义了一个方法, 也就是说, 只要一个类型实现了这个 &lt;code class=&quot;highlighter-rouge&quot;&gt;ServeHTTP&lt;/code&gt; 方法, 我们就可以把该类型的变量直接赋值给 Handler接口, 这在后面的具体内部实现中多次出现, 很有用。&lt;/p&gt;

&lt;h4 id=&quot;servemux-结构体&quot;&gt;ServeMux 结构体&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type ServeMux struct {
	mu    sync.RWMutex
	m     map[string]muxEntry
	hosts bool // whether any patterns contain hostnames
}

type muxEntry struct {
	explicit bool
	h        Handler
	pattern  string
}

// NewServeMux allocates and returns a new ServeMux.
func NewServeMux() *ServeMux { return &amp;amp;ServeMux{m: make(map[string]muxEntry)} }

var DefaultServeMux = NewServeMux()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;ServeMux结构说明
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ServeMux
     mu    : 用于并发控制的锁
     m     : 存有muxEntry的map (key 为 pattern)
     hosts : 用于判断模式中是否包含主机名
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;muxEntry结构说明
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // 每一个 muxEntry 对应一个处理函数
 muxEntry
     explicit : 当为 true 时表明该 pattern 已注册, 防止再次有相同 pattern 进行注册
     h        : 处理函数 (如本例中的 handleRequest 函数)
     pattern  : 模式 (如本例中的 &quot;/&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;DefaultServeMux 为默认的 &lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP request multiplexer&lt;/code&gt;, 当服务端程序未指明特定的 multiplexer 时, 就会使用这个http包中声明好的 ServeMux 实例。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于 ServeMux 结构体, http包中的注释如下所示:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;ServeMux is an HTTP request multiplexer.
 It matches the URL of each incoming request against a list of registered
 patterns and calls the handler for the pattern that
 most closely matches the URL.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单来说, ServeMux这个结构体主要存储了不同 pattern 对应的逻辑处理函数 (存储于一个map中)。&lt;/p&gt;

&lt;p&gt;对于每一个请求, 将其 url 与已注册 pattern 匹配, 若匹配成功, 则调用相应的处理函数。&lt;/p&gt;

&lt;h4 id=&quot;handlerfunc类型&quot;&gt;HandlerFunc类型&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(w, r).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
	f(w, r)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;HandlerFunc类型实现了ServeHTTP方法, 因此可以赋值给前面提到的Handler接口&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 区分 HandlerFunc(类型) 和 HandleFunc(函数)&lt;/p&gt;

&lt;h4 id=&quot;serverhandler结构体&quot;&gt;serverHandler结构体&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type serverHandler struct {
    srv *Server
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;该结构体类型也实现了ServeHTTP方法, 也可以赋值给Handler接口&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;下面进行具体的源码分析:&lt;/p&gt;

&lt;h3 id=&quot;httphandlefunc&quot;&gt;http.HandleFunc&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// HandleFunc registers the handler function for the given pattern
// in the DefaultServeMux.
// The documentation for ServeMux explains how patterns are matched.
func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
	DefaultServeMux.HandleFunc(pattern, handler)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;http.HandleFunc 中,&lt;/p&gt;

&lt;p&gt;调用了ServeMux.HandleFunc方法 (receiver 为 DefaultServeMux), 传入参数 “/” 和 handleRequest 函数&lt;/p&gt;

&lt;h3 id=&quot;servemuxhandlefunc&quot;&gt;ServeMux.HandleFunc&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// HandleFunc registers the handler function for the given pattern.
func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
	mux.Handle(pattern, HandlerFunc(handler))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;ServeMux.HandleFunc中,&lt;/p&gt;

&lt;p&gt;将传入的handler (即handleRequest函数) 强制类型转换为 HandlerFunc 类型 (如前面提到的, 该类型实现了Handler接口, 可以赋值给Handler接口)&lt;/p&gt;

&lt;p&gt;然后, 调用了 ServeMux.Handle 方法 (receiver 为 DefaultServeMux), 传入参数”/”和已变为 HandlerFunc 类型的 handleRequest 函数&lt;/p&gt;

&lt;h3 id=&quot;servemuxhandle&quot;&gt;ServeMux.Handle&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Handle registers the handler for the given pattern.
// If a handler already exists for pattern, Handle panics.
func (mux *ServeMux) Handle(pattern string, handler Handler) {
	mux.mu.Lock()
	defer mux.mu.Unlock()

	if pattern == &quot;&quot; {
		panic(&quot;http: invalid pattern &quot; + pattern)
	}
	if handler == nil {
		panic(&quot;http: nil handler&quot;)
	}
	if mux.m[pattern].explicit {
		panic(&quot;http: multiple registrations for &quot; + pattern)
	}

	mux.m[pattern] = muxEntry{explicit: true, h: handler, pattern: pattern}

	if pattern[0] != '/' {
		mux.hosts = true
	}

	// Helpful behavior:
	// If pattern is /tree/, insert an implicit permanent redirect for /tree.
	// It can be overridden by an explicit registration.
	n := len(pattern)
	if n &amp;gt; 0 &amp;amp;&amp;amp; pattern[n-1] == '/' &amp;amp;&amp;amp; !mux.m[pattern[0:n-1]].explicit {
		// If pattern contains a host name, strip it and use remaining
		// path for redirect.
		path := pattern
		if pattern[0] != '/' {
			// In pattern, at least the last character is a '/', so
			// strings.Index can't be -1.
			path = pattern[strings.Index(pattern, &quot;/&quot;):]
		}
		url := &amp;amp;url.URL{Path: path}
		mux.m[pattern[0:n-1]] = muxEntry{h: RedirectHandler(url.String(), StatusMovedPermanently), pattern: pattern}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ServeMux.Handle中,&lt;/p&gt;

&lt;p&gt;前面主要进行了输入参数(pattern 和 handler)的合法性检测&lt;/p&gt;

&lt;p&gt;我们重点关注这一行代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mux.m[pattern] = muxEntry{explicit: true, h: handler, pattern: pattern}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这行代码声明并初始化了一个muxEntry结构体, 并根据其 pattern 将其放到 DefaultServeMux 的 map &lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt; 中, 实现了相应路由处理函数的注册&lt;/p&gt;

&lt;p&gt;(注: 将 explicit 设为 true 表明该 pattern 已注册, 当有相同 pattern 进行注册时, 会调用panic函数)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;至此, main中第一个关键函数调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;http.HandleFunc(&quot;/&quot;, HandleRequest)&lt;/code&gt; 就分析完毕了, 实际上就是把 pattern(“/”) 和 handler(HandleRequest) 存入 DefaultServeMux 的 map 中&lt;/p&gt;

&lt;p&gt;下面对第二个关键调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;http.ListenAndServe(&quot;:9090&quot;, nil)&lt;/code&gt; 进行分析&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;httplistenandserve&quot;&gt;http.ListenAndServe&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ListenAndServe always returns a non-nil error.
func ListenAndServe(addr string, handler Handler) error {
	server := &amp;amp;Server{Addr: addr, Handler: handler}
	return server.ListenAndServe()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;http.ListenAndServe中,&lt;/p&gt;

&lt;p&gt;首先用传入的参数 (“:9090” &amp;amp; nil) 初始化了一个Server结构体&lt;/p&gt;

&lt;p&gt;然后调用了Server.ListenAndServe方法 (receiver 为刚创建的server)&lt;/p&gt;

&lt;h3 id=&quot;serverlistenandserve&quot;&gt;Server.ListenAndServe&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ListenAndServe listens on the TCP network address srv.Addr and then
// calls Serve to handle requests on incoming connections.
// Accepted connections are configured to enable TCP keep-alives.
// If srv.Addr is blank, &quot;:http&quot; is used.
// ListenAndServe always returns a non-nil error.
func (srv *Server) ListenAndServe() error {
	addr := srv.Addr
	if addr == &quot;&quot; {
		addr = &quot;:http&quot;
	}
	ln, err := net.Listen(&quot;tcp&quot;, addr)
	if err != nil {
		return err
	}
	return srv.Serve(tcpKeepAliveListener{ln.(*net.TCPListener)})
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Server.ListenAndServe中,&lt;/p&gt;

&lt;p&gt;对给定的端口进行监听 (基于TCP协议)&lt;/p&gt;

&lt;p&gt;并调用Server.Serve函数(receiver 为之前创建的实例 server), 传入参数 ln (调用listen函数后返回的Listener接口)&lt;/p&gt;

&lt;h3 id=&quot;serverserve&quot;&gt;Server.Serve&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Serve accepts incoming connections on the Listener l, creating a
// new service goroutine for each. The service goroutines read requests and
// then call srv.Handler to reply to them.
// Serve always returns a non-nil error.
func (srv *Server) Serve(l net.Listener) error {
	defer l.Close()
	if fn := testHookServerServe; fn != nil {
		fn(srv, l)
	}
	var tempDelay time.Duration // how long to sleep on accept failure
	if err := srv.setupHTTP2(); err != nil {
		return err
	}
	for {
		rw, e := l.Accept()
		if e != nil {
			if ne, ok := e.(net.Error); ok &amp;amp;&amp;amp; ne.Temporary() {
				if tempDelay == 0 {
					tempDelay = 5 * time.Millisecond
				} else {
					tempDelay *= 2
				}
				if max := 1 * time.Second; tempDelay &amp;gt; max {
					tempDelay = max
				}
				srv.logf(&quot;http: Accept error: %v; retrying in %v&quot;, e, tempDelay)
				time.Sleep(tempDelay)
				continue
			}
			return e
		}
		tempDelay = 0
		c := srv.newConn(rw)
		c.setState(c.rwc, StateNew) // before Serve can return
		go c.serve()
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Server.Serve中,
可将上述代码简化为:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for {
    rw, e := l.Accept()
    ...
    c, err := srv.newConn(rw)
    ...
    go c.serve()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Listener 接收请求&lt;/p&gt;

&lt;p&gt;当接收到请求时, 建立新连接&lt;/p&gt;

&lt;p&gt;并用 goroutine 运行 conn.serve (receiver 为 建立新连接后返回的 Conn指针 &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;)&lt;/p&gt;

&lt;h3 id=&quot;connserve&quot;&gt;conn.serve&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Serve a new connection.
func (c *conn) serve() {
	c.remoteAddr = c.rwc.RemoteAddr().String()
	defer func() {
		if err := recover(); err != nil {
			const size = 64 &amp;lt;&amp;lt; 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			c.server.logf(&quot;http: panic serving %v: %v\n%s&quot;, c.remoteAddr, err, buf)
		}
		if !c.hijacked() {
			c.close()
			c.setState(c.rwc, StateClosed)
		}
	}()

	if tlsConn, ok := c.rwc.(*tls.Conn); ok {
		if d := c.server.ReadTimeout; d != 0 {
			c.rwc.SetReadDeadline(time.Now().Add(d))
		}
		if d := c.server.WriteTimeout; d != 0 {
			c.rwc.SetWriteDeadline(time.Now().Add(d))
		}
		if err := tlsConn.Handshake(); err != nil {
			c.server.logf(&quot;http: TLS handshake error from %s: %v&quot;, c.rwc.RemoteAddr(), err)
			return
		}
		c.tlsState = new(tls.ConnectionState)
		*c.tlsState = tlsConn.ConnectionState()
		if proto := c.tlsState.NegotiatedProtocol; validNPN(proto) {
			if fn := c.server.TLSNextProto[proto]; fn != nil {
				h := initNPNRequest{tlsConn, serverHandler{c.server}}
				fn(c.server, tlsConn, h)
			}
			return
		}
	}

	c.r = &amp;amp;connReader{r: c.rwc}
	c.bufr = newBufioReader(c.r)
	c.bufw = newBufioWriterSize(checkConnErrorWriter{c}, 4&amp;lt;&amp;lt;10)

	for {
		w, err := c.readRequest()
		if c.r.remain != c.server.initialReadLimitSize() {
			// If we read any bytes off the wire, we're active.
			c.setState(c.rwc, StateActive)
		}
		if err != nil {
			if err == errTooLarge {
				// Their HTTP client may or may not be
				// able to read this if we're
				// responding to them and hanging up
				// while they're still writing their
				// request.  Undefined behavior.
				io.WriteString(c.rwc, &quot;HTTP/1.1 431 Request Header Fields Too Large\r\nContent-Type: text/plain\r\nConnection: close\r\n\r\n431 Request Header Fields Too Large&quot;)
				c.closeWriteAndWait()
				return
			}
			if err == io.EOF {
				return // don't reply
			}
			if neterr, ok := err.(net.Error); ok &amp;amp;&amp;amp; neterr.Timeout() {
				return // don't reply
			}
			var publicErr string
			if v, ok := err.(badRequestError); ok {
				publicErr = &quot;: &quot; + string(v)
			}
			io.WriteString(c.rwc, &quot;HTTP/1.1 400 Bad Request\r\nContent-Type: text/plain\r\nConnection: close\r\n\r\n400 Bad Request&quot;+publicErr)
			return
		}

		// Expect 100 Continue support
		req := w.req
		if req.expectsContinue() {
			if req.ProtoAtLeast(1, 1) &amp;amp;&amp;amp; req.ContentLength != 0 {
				// Wrap the Body reader with one that replies on the connection
				req.Body = &amp;amp;expectContinueReader{readCloser: req.Body, resp: w}
			}
		} else if req.Header.get(&quot;Expect&quot;) != &quot;&quot; {
			w.sendExpectationFailed()
			return
		}

		// HTTP cannot have multiple simultaneous active requests.[*]
		// Until the server replies to this request, it can't read another,
		// so we might as well run the handler in this goroutine.
		// [*] Not strictly true: HTTP pipelining.  We could let them all process
		// in parallel even if their responses need to be serialized.
		serverHandler{c.server}.ServeHTTP(w, w.req)
		if c.hijacked() {
			return
		}
		w.finishRequest()
		if !w.shouldReuseConnection() {
			if w.requestBodyLimitHit || w.closedRequestBodyEarly() {
				c.closeWriteAndWait()
			}
			return
		}
		c.setState(c.rwc, StateIdle)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;类似的, 我们重点关注for循环部分并将其简化为:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for{
  w, err := c.readRequest()
  ...
  serverHandler{c.server}.ServeHTTP(w, w.req)
  ...
  w.finishRequest()
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对于同一个连接, 循环地执行读取请求, 处理请求, 完成请求三个操作&lt;/p&gt;

&lt;p&gt;对于其中三个操作, 我们重点看处理请求部分&lt;/p&gt;

&lt;p&gt;即: &lt;code class=&quot;highlighter-rouge&quot;&gt;serverHandler{c.server}.ServeHTTP(w, w.req)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;该语句调用了 serverHandler.ServeHTTP 方法&lt;/p&gt;

&lt;h3 id=&quot;serverhandlerservehttp&quot;&gt;serverHandler.ServeHTTP&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {
    handler := sh.srv.Handler
    if handler == nil {
        handler = DefaultServeMux
    }
    if req.RequestURI == &quot;*&quot; &amp;amp;&amp;amp; req.Method == &quot;OPTIONS&quot; {
        handler = globalOptionsHandler{}
    }
    handler.ServeHTTP(rw, req)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;serverHandler.ServeHTTP中,&lt;/p&gt;

&lt;p&gt;根据我们在一开始调用http.ListenAndServe函数时传入的handler参数来确定 handler (ServeMux结构体类型), 若传入为 &lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;, 则 handler 为默认的 DefaultServeMux,
然后调用 ServeMux.ServeHTTP 方法 (receiver 为handler, 本例中即为 DefaultServeMux)&lt;/p&gt;

&lt;h3 id=&quot;servemuxservehttp&quot;&gt;ServeMux.ServeHTTP&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ServeHTTP dispatches the request to the handler whose
// pattern most closely matches the request URL.
func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {
	if r.RequestURI == &quot;*&quot; {
		if r.ProtoAtLeast(1, 1) {
			w.Header().Set(&quot;Connection&quot;, &quot;close&quot;)
		}
		w.WriteHeader(StatusBadRequest)
		return
	}
	h, _ := mux.Handler(r)
	h.ServeHTTP(w, r)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ServeMux.ServeHTTP中,&lt;/p&gt;

&lt;p&gt;我们主要关注下面两行代码:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;h, _ := mux.Handler(r)
h.ServeHTTP(w, r)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;第一行代码 调用了 ServeMux.Handler 方法 (此处 receiver 为 DefaultServeMux), 传入请求 &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt;, 返回相应的逻辑处理函数 (HandlerFunc 类型)&lt;/p&gt;

&lt;p&gt;第二行代码 则是执行返回的 handler 的 ServeHTTP 方法(即 &lt;code class=&quot;highlighter-rouge&quot;&gt;HandlerFunc.ServeHTTP&lt;/code&gt;, 该方法在前面的 &lt;code class=&quot;highlighter-rouge&quot;&gt;内置结构体 &amp;amp; 类型 定义&lt;/code&gt; 那节给出, 实际上就是执行了 receiver 本身)&lt;/p&gt;

&lt;p&gt;至于 ServeMux.Handler, 其具体实现如下所示&lt;/p&gt;

&lt;h3 id=&quot;servemuxhandler&quot;&gt;ServeMux.Handler&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) {
	if r.Method != &quot;CONNECT&quot; {
		if p := cleanPath(r.URL.Path); p != r.URL.Path {
			_, pattern = mux.handler(r.Host, p)
			url := *r.URL
			url.Path = p
			return RedirectHandler(url.String(), StatusMovedPermanently), pattern
		}
	}

	return mux.handler(r.Host, r.URL.Path)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;ServeMux.Handler中,&lt;/p&gt;

&lt;p&gt;调用了 ServeMux.handler 方法(receiver 为 DefaultServeMux), 传入请求 &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; 的 主机名 &amp;amp; URL的路径部分&lt;/p&gt;

&lt;h3 id=&quot;servemuxhandler-1&quot;&gt;ServeMux.handler&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (mux *ServeMux) handler(host, path string) (h Handler, pattern string) {
    mux.mu.RLock()
    defer mux.mu.RUnlock()

    // Host-specific pattern takes precedence over generic ones
    if mux.hosts {
        h, pattern = mux.match(host + path)
    }
    if h == nil {
        h, pattern = mux.match(path)
    }
    if h == nil {
        h, pattern = NotFoundHandler(), &quot;&quot;
    }
    return
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;ServeMux.Handler中,&lt;/p&gt;

&lt;p&gt;调用 ServeMux.match 方法, 传入相应的请求路径, 返回 匹配的 handler 和 pattern&lt;/p&gt;

&lt;h3 id=&quot;servemuxmatch&quot;&gt;ServeMux.match&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (mux *ServeMux) match(path string) (h Handler, pattern string) {
	var n = 0
	for k, v := range mux.m {
		if !pathMatch(k, path) {
			continue
		}
		if h == nil || len(k) &amp;gt; n {
			n = len(k)
			h = v.h
			pattern = v.pattern
		}
	}
	return
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ServeMux.match中,&lt;/p&gt;

&lt;p&gt;遍历 receiver (此处为 DefaultServeMux) 的 map, 对于输入的路径, 找到能与之相匹配的已注册pattern, 返回 相应的 handler 和 pattern&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;最后, 重新整理一下主要的函数调用过程:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;main
├── http.HandleFunc
|   └── ServeMux.HandleFunc
|       └── ServeMux.Handle
└── http.ListenAndServe
    └── Server.ListenAndServe
        ├── net.Listen
        └── Server.Serve
            ├── Listener.Accept
            ├── Server.newConn
            └── conn.serve
                ├── conn.readRequest
                ├── serverHandler.ServeHTTP
                |   └── ServeMux.ServeHTTP
                |       ├── ServeMux.Handler
                |       |   └── ServeMux.handler
                |       |       └── ServeMux.match
                |       └── HandlerFunc.ServeHTTP
                └── response.finishRequest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;至此, 对于实现web服务器搭建部分的http源码就基本分析完啦。&lt;/p&gt;

&lt;p&gt;注: 代码高亮暂时存在问题, 等以后解决了再更新。(貌似暂不支持golang语法高亮)&lt;/p&gt;
</description>
        <pubDate>Thu, 16 Nov 2017 23:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/11/16/go-http-src-analysis/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/11/16/go-http-src-analysis/</guid>
        
        <category>go</category>
        
        <category>http</category>
        
        
      </item>
    
      <item>
        <title>Welcome to Yezh Blog</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“This is the beginning.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;Yezh 的 blog 开通啦!&lt;/p&gt;

&lt;p&gt;现在开始, 我将不定期更新我的博客。&lt;/p&gt;

&lt;p&gt;内容主要为技术帖。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;

&lt;p&gt;一开始打算直接弄一个 CSDN 博客, 但是在注册时用户名老是重复, 不重复的又不好记, 于是就暂时搁置了。&lt;/p&gt;

&lt;p&gt;后来发现 &lt;code class=&quot;highlighter-rouge&quot;&gt;Github Pages&lt;/code&gt; 可以免费托管静态内容, 了解后发现并不难, 于是就开始正式搭建我的博客啦。&lt;/p&gt;

&lt;p&gt;我采用的技术方案为: &lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt; + &lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其优点有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可直接采用 &lt;strong&gt;Markdown&lt;/strong&gt; 书写&lt;/li&gt;
  &lt;li&gt;采用 Git workflow ，&lt;strong&gt;Git Commit 即 Blog Post&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;免费无限空间 (不用自己折腾主机)&lt;/li&gt;
  &lt;li&gt;可自定义域名 (只需简单改改 DNS, 加个 CNAME 就好了)&lt;/li&gt;
  &lt;li&gt;Jekyll 自定制实现容易&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;博客搭建的过程主要参照了 &lt;a href=&quot;http://qiubaiying.top/2017/02/06/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/&quot;&gt;利用 GitHub Pages 快速搭建博客&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;致谢&quot;&gt;致谢&lt;/h2&gt;

&lt;p&gt;最后, 感谢 &lt;a href=&quot;https://github.com/huxpro&quot;&gt;Huxpro&lt;/a&gt; 提供的博客模板 和 &lt;a href=&quot;https://github.com/qiubaiying&quot;&gt;qiubaiying&lt;/a&gt; 的博客搭建教程。&lt;/p&gt;
</description>
        <pubDate>Wed, 15 Nov 2017 09:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/11/15/hello-blog/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/11/15/hello-blog/</guid>
        
        <category>blog</category>
        
        
      </item>
    
  </channel>
</rss>
