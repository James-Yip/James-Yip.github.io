<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Yezh Blog</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 11 Mar 2019 07:41:36 +0000</pubDate>
    <lastBuildDate>Mon, 11 Mar 2019 07:41:36 +0000</lastBuildDate>
    <generator>Jekyll v3.6.2</generator>
    
      <item>
        <title>利用OpenVPN搭建简单VPN</title>
        <description>&lt;h2 id=&quot;安装openvpn&quot;&gt;安装OpenVPN&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get install openvpn easy-rsa
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;安装完毕后, 在终端输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;openvpn&lt;/code&gt; 即可以看到一系列用法提示。&lt;/p&gt;

&lt;p&gt;注: 此处同时安装了 easy-rsa 脚本工具, 用来生成所需证书。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;生成openvpn相关证书&quot;&gt;生成OpenVPN相关证书&lt;/h2&gt;

&lt;h3 id=&quot;创建ca目录&quot;&gt;创建CA目录&lt;/h3&gt;

&lt;p&gt;选择一个目录, 在该目录下建立 &lt;code class=&quot;highlighter-rouge&quot;&gt;openvpn-ca&lt;/code&gt; 目录(命名随意, 易懂即可), 并将上一步安装好的easy-rsa的所有文件从默认安装目录中复制到刚刚建立的CA目录下。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mkdir openvpn-ca
$ cp -r /usr/share/easy-rsa/* ./openvpn-ca/
$ cd openvpn-ca/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;完成后进入 openvpn-ca 目录, 进行生成相关证书所需的操作。&lt;/p&gt;

&lt;h3 id=&quot;配置ca变量&quot;&gt;配置CA变量&lt;/h3&gt;
&lt;p&gt;用文本编辑器打开当前目录下的 &lt;code class=&quot;highlighter-rouge&quot;&gt;vars&lt;/code&gt; 文件, 会发现里面是一个shell脚本, 大致浏览一遍后就知道该文件其实就是一个配置文件, 里面导出了许多生成证书所需的环境变量。&lt;/p&gt;

&lt;p&gt;接下来对其中的部分变量进行修改, 以生成所需证书。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# These are the default values for fields&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# which will be placed in the certificate.&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Don't leave any of these fields blank.&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;KEY_COUNTRY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;US&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;KEY_PROVINCE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;CA&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;KEY_CITY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;SanFrancisco&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;KEY_ORG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Fort-Funston&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;KEY_EMAIL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;me@myhost.mydomain&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;KEY_OU&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;MyOrganizationalUnit&quot;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# X509 Subject Field&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;KEY_NAME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;EasyRSA&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;将上面的变量值修改为与你对应的信息, 注意不能为空。&lt;/p&gt;

&lt;p&gt;下面为我的修改:&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;KEY_COUNTRY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;CN&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;KEY_PROVINCE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;GD&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;KEY_CITY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Guangzhou&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;KEY_ORG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;SYSU&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;KEY_EMAIL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;874244887@qq.com&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;KEY_OU&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;SDCS&quot;&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;KEY_NAME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;server&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;配置完成后, 保存并在终端输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;source vars&lt;/code&gt;, 使刚刚配置的环境变量生效。
无误的话, 应该会看到与下面类似的提示信息:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ source vars
NOTE: If you run ./clean-all, I will be doing a rm -rf on /home/james/Study/webSecurity/openvpn/server/openvpn-ca/keys
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;生成ca证书&quot;&gt;生成CA证书&lt;/h3&gt;
&lt;p&gt;在生成证书前, 先执行当前目录下的 clean-all 文件, 清空所有的keys(如果有的话)&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ ./clean-all&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;生成OpenVPN的根证书&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ ./build-ca&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;执行build-ca文件, 生成根证书颁发机构密钥（rootcertificate authority key ）和证书（certificate）&lt;/p&gt;

    &lt;p&gt;注: 由于我们刚刚修改了vars文件，证书生成所需变量的值都会自动填充，因此, 运行时只需按回车确认即可。&lt;/p&gt;

    &lt;p&gt;输出内容如下：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ ./build-ca
 Generating a 2048 bit RSA private key
 ...........+++
 ....+++
 writing new private key to 'ca.key'
 -----
 You are about to be asked to enter information that will be incorporated
 into your certificate request.
 What you are about to enter is what is called a Distinguished Name or a DN.
 There are quite a few fields but you can leave some blank
 For some fields there will be a default value,
 If you enter '.', the field will be left blank.
 -----
 Country Name (2 letter code) [CN]:
 State or Province Name (full name) [GD]:
 Locality Name (eg, city) [Guangzhou]:
 Organization Name (eg, company) [SYSU]:
 Organizational Unit Name (eg, section) [SDCS]:
 Common Name (eg, your name or your server's hostname) [SYSU CA]:zhengshu
 Name [server]:
 Email Address [874244887@qq.com]:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;执行完成后, 可以看到当前目录下多了一个keys目录, 其中存有我们刚刚生成的根证书。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;生成服务端所需证书&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ ./build-key-server server&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;执行build-key-server文件, 指定服务端证书文件名为 server&lt;/p&gt;

    &lt;p&gt;执行过程中一路回车，中间出现 challenge password ，不要输入任何值, 也是按回车，到最后会有两个问题，输入y即可。&lt;/p&gt;

    &lt;p&gt;输出内容很长, 此处就不粘贴出来了。&lt;/p&gt;

    &lt;p&gt;执行完成后, 可以看到keys目录下新增了server.crt、server.key 和 server.csr三个文件。(其中server.crt和server.key两个文件是我们所需要的)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;生成客户端所需证书&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ ./build-key client1&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;执行build-key文件, 指定客户端证书文件名为 client1&lt;/p&gt;

    &lt;p&gt;执行过程所需操作与生成服务端证书时相同。&lt;/p&gt;

    &lt;p&gt;同样, 执行完成后, 可以看到keys目录下新增了client1.crt、client1.key 和 client1.csr三个文件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;生成Diffle Hellman参数&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ ./build-dh&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;执行build-dh文件, 为服务端生成加密交换时所需的Diffie-Hellman文件
 执行可能需要较长时间, 完成后可在keys目录下看到新增的dh2048.pem文件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;生成HMAC签名&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ openvpn --genkey --secret keys/ta.key&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;执行上述指令生成一个HMAC签名, 以增强服务端的TLS完整性验证能力。&lt;/p&gt;

    &lt;p&gt;注: &lt;code class=&quot;highlighter-rouge&quot;&gt;keys/ta.key&lt;/code&gt; 表示将生成的ta.key(一般这样命名)放到keys目录下。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;至此, 所需的CA证书等文件就都生成好了。 接下来, 进行OpenVPN的具体配置。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;openvpn服务端配置&quot;&gt;OpenVPN服务端配置&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;复制相关文件到OpenVPN目录下&lt;/p&gt;

    &lt;p&gt;先将之前生成的相关文件复制到 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/openvpn&lt;/code&gt; 配置目录下&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ cd keys/
 $ sudo cp ca.crt ca.key server.crt server.key ta.key dh2048.pem /etc/openvpn/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;然后将OpenVPN自带的配置模板也复制到该目录下并解压&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ sudo cp /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz /etc/openvpn/

 $ sudo gzip -d /etc/openvpn/server.conf.gz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改OpenVPN服务端配置文件&lt;/p&gt;

    &lt;p&gt;用文本编辑器打开 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/openvpn&lt;/code&gt; 目录下的 server.conf 文件(以root权限), 对其进行如下修改:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;搜索 tls-auth (找到HMAC部分), 移除其开头的”;”，来解注释tls-auth，并且在tls-auth的下一行增加一个key-direction参数，参数值设为0，如下所示：&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  tls-auth ta.key 0 # This file is secret
  key-direction 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;搜索cipher(找到加密部分)，这里我选择的是 AES-128-cbc 加密算法。移除其开头的”;”, 启用该加密算法, 并且在下一行添加一个auth行（身份验证行）来选择HMAC消息摘要算法，此处使用的是SHA256消息摘要算法, 如下所示：&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  cipher AES-128-CBC
  auth SHA256
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;找到user和group参数，去除它们开头的”;”，如下所示：&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  user nobody
  group nogroup
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;网络配置&quot;&gt;网络配置&lt;/h2&gt;

&lt;p&gt;为了让OpenVPN服务端可以正确路由流量, 我们需要进行一些网络配置。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;允许IP转发&lt;/p&gt;

    &lt;p&gt;为了提供最基本的VPN服务, 我们需要允许服务端所在主机允许IP转发, 即能让服务端转发流量。&lt;/p&gt;

    &lt;p&gt;以root权限打开 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/sysctl.conf&lt;/code&gt; 文件, 搜索net.ipv4.ip_forward, 移除开头的”#”, 来启用IP转发, 改完后保存退出。&lt;/p&gt;

    &lt;p&gt;为了让刚刚的修改生效, 还需要执行如下指令:&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ sudo sysctl -p&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;执行后应该会看到如下输出:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ sudo sysctl -p
 net.ipv4.ip_forward = 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;配置防火墙规则&lt;/p&gt;

    &lt;p&gt;接着, 我们需要配置防火墙规则来引导进入服务器的流量。&lt;/p&gt;

    &lt;p&gt;具体配置前, 我们需要确定当前服务器的&lt;strong&gt;公共网络接口&lt;/strong&gt;(即网卡名称), 执行如下指令:&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ ip route | grep default&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;可以看到终端中输出了一行内容, 而我们需要的接口应该是紧跟在 “dev” 后面的字符串&lt;/p&gt;

    &lt;p&gt;例如, 我的输出如下, 则我的公共网络接口为 &lt;code class=&quot;highlighter-rouge&quot;&gt;enp2s0&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ ip route | grep default
 default via 172.18.159.254 dev enp2s0  proto static  metric 100
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;知道接口后, 我们就可以进行具体的UFW规则配置(为NAT表设置POSTROUTING默认规则)，从而为来自VPN的任何流量设置伪装连接。&lt;/p&gt;

    &lt;p&gt;以root权限打开 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/ufw/before.rules&lt;/code&gt; 文件, 并在文件开头加入部分内容, 如下所示:&lt;/p&gt;

    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;
 &lt;span class=&quot;c&quot;&gt;# rules.before&lt;/span&gt;
 &lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;
 &lt;span class=&quot;c&quot;&gt;# Rules that should be run before the ufw command line added rules. Custom&lt;/span&gt;
 &lt;span class=&quot;c&quot;&gt;# rules should be added to one of these chains:&lt;/span&gt;
 &lt;span class=&quot;c&quot;&gt;#   ufw-before-input&lt;/span&gt;
 &lt;span class=&quot;c&quot;&gt;#   ufw-before-output&lt;/span&gt;
 &lt;span class=&quot;c&quot;&gt;#   ufw-before-forward&lt;/span&gt;
 &lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;

 &lt;span class=&quot;c&quot;&gt;# START OPENVPN RULES&lt;/span&gt;
 &lt;span class=&quot;c&quot;&gt;# NAT table rules&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;nat
 :POSTROUTING ACCEPT &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;0:0]
 &lt;span class=&quot;c&quot;&gt;# Allow traffic from OpenVPN client to enp2s0(changeto the interface you discovered!)&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;-A&lt;/span&gt; POSTROUTING &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; 10.8.0.0/8 &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; enp2s0 &lt;span class=&quot;nt&quot;&gt;-jMASQUERADE&lt;/span&gt;
 COMMIT
 &lt;span class=&quot;c&quot;&gt;# END OPENVPN RULES&lt;/span&gt;

 &lt;span class=&quot;c&quot;&gt;# Don't delete these required lines, otherwise there will be errors&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;filter
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 公共网络接口要用你刚刚查到的自己的网卡名称&lt;/p&gt;

    &lt;p&gt;添加后保存退出。&lt;/p&gt;

    &lt;p&gt;最后, 我们让防火墙默认允许转发包:&lt;/p&gt;

    &lt;p&gt;以root权限打开 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/default/ufw&lt;/code&gt; 文件, 搜索 DEFAULT_FORWARD_POLICY, 并将其值从DROP改为ACCEPT, 如下所示:&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DEFAULT_FORWARD_POLICY=&quot;ACCEPT&quot;&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;修改后保存退出。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;打开OpenVPN端口并使变化生效&lt;/p&gt;

    &lt;p&gt;最后, 我们需要对防火墙进行调整以允许流量到OpenVPN服务端。&lt;/p&gt;

    &lt;p&gt;配置防火墙允许UDP流量到1194端口(OpenVPN服务端默认使用端口):&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ sudo ufw allow 1194/udp&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;启动防火墙, 并查看当前防火墙状态:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ sudo ufw enable
 在系统启动时启用和激活防火墙
 $ sudo ufw status
 状态： 激活

 至                          动作          来自
 -                          --          --
 1194/udp                   ALLOW       Anywhere
 1194/udp (v6)              ALLOW       Anywhere (v6)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;至此, 服务端就可以成功获取到流量并对其进行进一步处理了。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;openvpn客户端配置&quot;&gt;OpenVPN客户端配置&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;创建客户端配置目录&lt;/p&gt;

    &lt;p&gt;选择一个目录, 在该目录下建立 &lt;code class=&quot;highlighter-rouge&quot;&gt;client-configs/keys&lt;/code&gt; 目录 (命名随意, 易懂即可)&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ mkdir -p client-configs/keys&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;由于客户端的密钥会放到这个目录下, 所以我们有必要对该目录设置访问权限:&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ chmod 700 ./client-configs/keys&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;复制并修改客户端配置文件&lt;/p&gt;

    &lt;p&gt;将OpenVPN自带的客户端配置模板复制到我们刚刚创建的客户端配置目录中, 作为客户端的配置文件：&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ cp /usr/share/doc/openvpn/examples/sample-config-files/client.conf ./client-configs/client.ovpn&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;然后对该文件进行如下修改:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;搜索 hostname/IP, 将其下面的remote指令按如下格式修改:&lt;/p&gt;

        &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;remote your_server_IP_address 1194&lt;/code&gt;&lt;/p&gt;

        &lt;p&gt;注: your_server_IP_address 为OpenVPN服务端所在的公网IP地址。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;搜索 proto, 确保选择的传输协议与在server配置文件中的一致(此处选择的是udp), 即:&lt;/p&gt;

        &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;proto udp&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;搜索 user 和 group, 移除它们开头的”;”, 如下所示:&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  user nobody
  group nogroup
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;搜索 SSL/TLS parms, 将其下面的证书及密钥路径进行修改, 如下所示:&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ca ./keys/ca.crt
  cert ./keys/client1.crt
  key ./keys/client1.key
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;注: 若前面创建目录时与我不同, 则需按照你证书和密钥的实际存放路径进行书写&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;启动服务端&quot;&gt;启动服务端&lt;/h2&gt;

&lt;p&gt;通过如下指令启动服务端:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ openvpn --config /etc/openvpn/server.conf&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;运行上述指令尝试启动服务端, 但运行失败, 出现错误:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ openvpn --config /etc/openvpn/server.conf
Options error: --dh fails with 'dh2048.pem': No such file or directory
Options error: --cert fails with 'server.crt': No such file or directory
Options error: --key fails with 'server.key': No such file or directory
Options error: --tls-auth fails with 'ta.key': No such file or directory
Options error: Please correct these errors.
Use --help for more information.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由报错的信息可以知道应该是配置文件中之前生成的证书等文件的路径没有指明, 而找不到文件。&lt;/p&gt;

&lt;p&gt;用root权限打开server.conf文件, 搜索并修改相应位置的内容, 具体如下表所示:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;修改前&lt;/th&gt;
      &lt;th&gt;修改后&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;ca ca.crt&lt;/td&gt;
      &lt;td&gt;ca /etc/openvpn/ca.crt&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;cert server.crt&lt;/td&gt;
      &lt;td&gt;cert /etc/openvpn/server.crt&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;key server.key&lt;/td&gt;
      &lt;td&gt;key /etc/openvpn/server.key&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;tls-auth ta.key 0&lt;/td&gt;
      &lt;td&gt;tls-auth /etc/openvpn/ta.key 0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;dh dh2048.pem&lt;/td&gt;
      &lt;td&gt;dh /etc/openvpn/dh2048.pem&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;注: 此处也可以不修改, 但是需要在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/openvpn/&lt;/code&gt; 目录下运行上述启动服务端的指令。&lt;/p&gt;

&lt;p&gt;再次运行指令, 发现还是会报错:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ openvpn --config /etc/openvpn/server.conf
Options error: --key fails with '/etc/openvpn/server.key': Permission denied
Options error: --tls-auth fails with '/etc/openvpn/ta.key': Permission denied
Options error: Please correct these errors.
Use --help for more information.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从报错信息中可以看出是权限问题&lt;/p&gt;

&lt;p&gt;用root权限执行指令, 可成功运行,
最后可以看到 &lt;code class=&quot;highlighter-rouge&quot;&gt;Initialization Sequence Completed&lt;/code&gt; 信息, 表示服务端已启动。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;启动客户端&quot;&gt;启动客户端&lt;/h2&gt;

&lt;p&gt;在client.ovpn文件所在目录下, 运行如下指令, 启动客户端:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ openvpn --config client.ovpn&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;运行 ifconfig 指令后, 可看到新建立的虚拟网卡tun0, 可见客户端已成功连接上服务端。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/2017-11-24-construct-VPN/markdown-img-paste-20171123232833886.png&quot; alt=&quot;tun0&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;至此, 我们利用OpenVPN, 已经成功搭建了一个简单的VPN了。&lt;/p&gt;
</description>
        <pubDate>Thu, 23 Nov 2017 23:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/11/23/construct-VPN/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/11/23/construct-VPN/</guid>
        
        <category>VPN</category>
        
        
      </item>
    
      <item>
        <title>Go negroni-gzip源码分析</title>
        <description>&lt;h2 id=&quot;gzip概念&quot;&gt;gzip概念&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;GZIP最早由Jean-loup Gailly和Mark Adler创建，用于UNⅨ系统的文件压缩。我们在Linux中经常会用到后缀为.gz的文件，它们就是GZIP格式的。现今已经成为Internet 上使用非常普遍的一种数据压缩格式，或者说一种文件格式。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;gzip可用来对静态文件进行压缩, 以减少文件的传输时间和存储空间, 。大流量的WEB站点常常使用GZIP压缩技术来让减少响应时间, 提升用户的使用体验, 但同时压缩步骤的加入会增加服务器的负荷, 可以说是一种 “trade-off”。&lt;/p&gt;

&lt;p&gt;对于gzip, golang内置有&lt;code class=&quot;highlighter-rouge&quot;&gt;compress/gzip&lt;/code&gt;包可供使用。&lt;/p&gt;

&lt;p&gt;此处主要对用于 &lt;a href=&quot;https://github.com/urfave/negroni&quot;&gt;Negroni&lt;/a&gt; 组件的&lt;a href=&quot;https://github.com/phyber/negroni-gzip&quot;&gt;gzip&lt;/a&gt;包进行源码分析。&lt;/p&gt;

&lt;p&gt;该gzip包内部使用了go提供的 &lt;code class=&quot;highlighter-rouge&quot;&gt;compress/gzip&lt;/code&gt; 包,  具体实现并不复杂。&lt;/p&gt;

&lt;h2 id=&quot;用法&quot;&gt;用法&lt;/h2&gt;
&lt;p&gt;下面为开发者提供的一个简单样例:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;net/http&quot;&lt;/span&gt;

    &lt;span class=&quot;s2&quot;&gt;&quot;github.com/urfave/negroni&quot;&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;github.com/phyber/negroni-gzip/gzip&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mux&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewServeMux&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mux&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HandleFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    	  &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Welcome to the home page!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;negroni&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Classic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Use&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gzip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Gzip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gzip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DefaultCompression&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UseHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mux&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;:3000&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;该样例使用了negroni, 并在其中启用了gzip中间件, 该中间件在 request 预处理 或 response 后处理中对文件进行压缩或解压。&lt;/p&gt;

&lt;h2 id=&quot;negroni-gzip-源码分析&quot;&gt;negroni-gzip 源码分析&lt;/h2&gt;

&lt;p&gt;此处对 negroni-gzip 源码的分析分为两部分:&lt;/p&gt;

&lt;p&gt;对其中定义的结构体和常量的解释, 以及对函数和方法的分析。&lt;/p&gt;

&lt;h3 id=&quot;结构体--常量&quot;&gt;结构体 &amp;amp; 常量&lt;/h3&gt;

&lt;h4 id=&quot;gzipresponsewriter结构体&quot;&gt;gzipResponseWriter结构体&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type gzipResponseWriter struct {
	w *gzip.Writer
	negroni.ResponseWriter
	wroteHeader bool
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;结构体成员&lt;/th&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;解释&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;w&lt;/td&gt;
      &lt;td&gt;*gzip.Writer&lt;/td&gt;
      &lt;td&gt;用于写数据&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;negroni.ResponseWriter&lt;/td&gt;
      &lt;td&gt;匿名成员, gzipResponseWriter结构体可直接访问该接口的方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;wroteHeader&lt;/td&gt;
      &lt;td&gt;bool&lt;/td&gt;
      &lt;td&gt;记录是否已写了header, 避免重复写header&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;handler结构体&quot;&gt;handler结构体&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type handler struct {
	pool sync.Pool
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;handler结构体中只有一个成员 pool (类型为sync包中定义的&lt;a href=&quot;https://go-zh.org/pkg/sync/#Pool&quot;&gt;Pool&lt;/a&gt;结构体)&lt;/p&gt;

&lt;p&gt;pool 的作用是用于缓存那些已经分配了内存但是暂时还未使用的数据, 以供后续使用。(同时pool能够保证多个goroutines同时使用它时的安全性)&lt;/p&gt;

&lt;p&gt;其Put方法可以将一个任意类型的数据放入pool中;&lt;/p&gt;

&lt;p&gt;还有一个Get方法则可以从pool中随机选择一个item, 将其从pool中移除, 并返回给调用者。&lt;/p&gt;

&lt;h4 id=&quot;常量&quot;&gt;常量&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const (
	encodingGzip = &quot;gzip&quot;

	headerAcceptEncoding  = &quot;Accept-Encoding&quot;
	headerContentEncoding = &quot;Content-Encoding&quot;
	headerContentLength   = &quot;Content-Length&quot;
	headerContentType     = &quot;Content-Type&quot;
	headerVary            = &quot;Vary&quot;
	headerSecWebSocketKey = &quot;Sec-WebSocket-Key&quot;

	BestCompression    = gzip.BestCompression
	BestSpeed          = gzip.BestSpeed
	DefaultCompression = gzip.DefaultCompression
	NoCompression      = gzip.NoCompression
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注: 以上常量实际上是开发者直接从 &lt;code class=&quot;highlighter-rouge&quot;&gt;compress/gzip&lt;/code&gt; 包中复制过来的。&lt;/p&gt;

&lt;h3 id=&quot;gzip函数&quot;&gt;Gzip函数&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Gzip returns a handler which will handle the Gzip compression in ServeHTTP.
// Valid values for level are identical to those in the compress/gzip package.
func Gzip(level int) *handler {
	h := &amp;amp;handler{}
	h.pool.New = func() interface{} {
		gz, err := gzip.NewWriterLevel(ioutil.Discard, level)
		if err != nil {
			panic(err)
		}
		return gz
	}
	return h
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Gzip函数初始化了一个空handler结构体
并对其成员赋初值,
然后返回该handler h, 传给negroni的Use方法。&lt;/p&gt;

&lt;p&gt;注: 由于handler结构体类型定义了其ServeHTTP方法(该方法下面会进行分析), 所以handler实现了negroni.Handler接口(negroni的Use方法所需的传入参数), 可以赋值给该接口。&lt;/p&gt;

&lt;h3 id=&quot;handlerservehttp方法&quot;&gt;handler.ServeHTTP方法&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ServeHTTP wraps the http.ResponseWriter with a gzip.Writer.
func (h *handler) ServeHTTP(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) {
	// Skip compression if the client doesn't accept gzip encoding.
	if !strings.Contains(r.Header.Get(headerAcceptEncoding), encodingGzip) {juhao
		next(w, r)
		return
	}

	// Skip compression if client attempt WebSocket connection
	if len(r.Header.Get(headerSecWebSocketKey)) &amp;gt; 0 {
		next(w, r)
		return
	}

	// Retrieve gzip writer from the pool. Reset it to use the ResponseWriter.
	// This allows us to re-use an already allocated buffer rather than
	// allocating a new buffer for every request.
	// We defer g.pool.Put here so that the gz writer is returned to the
	// pool if any thing after here fails for some reason (functions in
	// next could potentially panic, etc)
	gz := h.pool.Get().(*gzip.Writer)
	defer h.pool.Put(gz)
	gz.Reset(w)juhao

	// Wrap the original http.ResponseWriter with negroni.ResponseWriter
	// and create the gzipResponseWriter.
	nrw := negroni.NewResponseWriter(w)
	grw := gzipResponseWriter{gz, nrw, false}

	// Call the next handler supplying the gzipResponseWriter instead of
	// the original.
	next(&amp;amp;grw, r)

	// Delete the content length after we know we have been written to.
	grw.Header().Del(headerContentLength)

	gz.Close()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;handler.ServeHTTP方法 的具体实现其实上述代码的注释中已经解释得很清晰了:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;对于某些情况(客户端不支持gzip编码 或 客户端正尝试建立socket连接)跳过压缩步骤, 直接进入下一个中间件处理;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;从pool中提取出 gzip writer, 并将其重置;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;调用 negroni.NewResponseWriter 方法 得到一个封装了http.ResponseWriter 以及 其它一些方法 的 negroni.ResponseWriter接口;(具体可见&lt;a href=&quot;https://github.com/urfave/negroni/blob/master/response_writer.go&quot;&gt;negroni相应源码&lt;/a&gt;)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将从第二第三步中得到的 gzip writer 和 negroni.ResponseWriter 作为初值 初始化创建一个 gzipResponseWriter结构体实例, 并将其传给下一个中间件;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;收尾工作。将gzipResponseWriter Header中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;headerContentLength&lt;/code&gt; 字段删除 并 关闭 gzip writer&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;gzipresponsewriterwriteheader方法&quot;&gt;gzipResponseWriter.WriteHeader方法&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Check whether underlying response is already pre-encoded and disable
// gzipWriter before the body gets written, otherwise encoding headers
func (grw *gzipResponseWriter) WriteHeader(code int) {
	headers := grw.ResponseWriter.Header()
	if headers.Get(headerContentEncoding) == &quot;&quot; {
		headers.Set(hegoaderContentEncoding, encodingGzip)
		headers.Add(headerVary, headerAcceptEncoding)
	} else {
		grw.w.Reset(ioutil.Discard)
		grw.w = nil
	}
	grw.ResponseWriter.WriteHeader(code)
	grw.wroteHeader = true
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如注释中所说, 该方法首先会检查 response 是否已经进行了编码,&lt;/p&gt;

&lt;p&gt;如果是, 则不会再进行gzip编码(将gzipWriter无效化并将gzipResponseWriter中类型为*gzip.Writer的成员w置空);&lt;/p&gt;

&lt;p&gt;否则, 则会将header中的Content-Encoding字段 设为 “gzip”, 表示使用gzip编码。&lt;/p&gt;

&lt;p&gt;最后, 无论是否使用gzip编码, 都会调用 http.ResponseWriter.WriteHeader 方法 进行基本的 Header 写操作(基于传入的返回码code)&lt;/p&gt;

&lt;p&gt;注意: 由于gzipResponseWriter结构体中有一个匿名成员negroni.ResponseWriter, 而该成员(接口)中又有匿名成员http.ResponseWriter(其有一个WriteHeader方法),
所以代码中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;grw.ResponseWriter.WriteHeader(code)&lt;/code&gt;
其实还可以简化为 &lt;code class=&quot;highlighter-rouge&quot;&gt;grw.WriteHeader(code)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;gzipresponsewriterwrite方法&quot;&gt;gzipResponseWriter.Write方法&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Write writes bytes to the gzip.Writer. It will also set the Content-Type
// header using the net/http library content type detection if the Content-Type
// header was not set yet.
func (grw *gzipResponseWriter) Write(b []byte) (int, error) {
	if !grw.wroteHeader {
		grw.WriteHeader(http.StatusOK)
	}
	if grw.w == nil {
		return grw.ResponseWriter.Write(b)
	}
	if len(grw.Header().Get(headerContentType)) == 0 {
		grw.Header().Set(headerContentType, http.DetectContentType(b))
	}
	return grw.w.Write(b)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同样, 如注释所说, 该方法 写数据到gzip.Writer。
另外, 如果header的Content-Type字段还未设置, 则会通过调用 net/http包中的DetectContentType函数来自动确定Content-Type, 并将其设置到header的Content-Type字段中。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;至此, 对negroni-gzip 的源码分析就基本完成啦。&lt;/p&gt;
</description>
        <pubDate>Tue, 21 Nov 2017 23:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/11/21/go-negroni-gzip/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/11/21/go-negroni-gzip/</guid>
        
        <category>go</category>
        
        
      </item>
    
      <item>
        <title>Golang http包源码分析</title>
        <description>&lt;h2 id=&quot;搭建简单web服务器&quot;&gt;搭建简单web服务器&lt;/h2&gt;
&lt;p&gt;利用 Go 内置的 net/http 包, 可以快速搭建一个简单的web服务器:&lt;/p&gt;

&lt;p&gt;main.go&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;net/http&quot;&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;strings&quot;&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;log&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handleRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;your&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;implementation&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blabla&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;route&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HandleFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handleRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Listening at port 9090...&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listen&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;9090&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serve&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requests&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ListenAndServe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;:9090&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;!= nil {
&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fatal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ListenAndServe: &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上面代码的运行结果就不贴出来了(因为也没什么输出hhh)&lt;/p&gt;

&lt;p&gt;接下来将以上面的程序为例, 具体分析http包在内部是如何实现的。&lt;/p&gt;

&lt;h2 id=&quot;http包内部实现&quot;&gt;http包内部实现&lt;/h2&gt;
&lt;p&gt;在上面给出的代码中, 实际上关键的函数就两个:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http.HandleFunc(&quot;/&quot;, handleRequest)

http.ListenAndServe(&quot;:9090&quot;, nil)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其功能正如注释中所说, 注册处理函数, 监听端口, 提供服务(当客户端 request url 的路径为 &lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt; 时, 调用handleRequest函数)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;为了了解http包的内部实现, 我们需要知道这两个函数内部究竟做了什么。&lt;/p&gt;

&lt;p&gt;具体源码可在当前 &lt;code class=&quot;highlighter-rouge&quot;&gt;$GOROOT&lt;/code&gt; 下的 src 目录下找到,
以我的电脑为例(Ubuntu 16.04), 源码的具体路径为:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/lib/go-1.6/src/net/http/server.go&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;注意事项:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;提供的源码路径仅供参考, 可能以后有了新版本的go, 文件目录结构又变了, 但一般内置的库都是放在 &lt;code class=&quot;highlighter-rouge&quot;&gt;$GOROOT&lt;/code&gt; 路径下的;&lt;/li&gt;
  &lt;li&gt;http目录下有两个同名文件server.go, 我们要研究的源码在 package 为 http 的 server.go 文件中 (另一个的 package 为 httptest)。&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;内置结构体--类型-定义&quot;&gt;内置结构体 &amp;amp; 类型 定义&lt;/h3&gt;
&lt;p&gt;在对函数进行分析前, 先列出其中出现的一些结构体以及接口等的类型定义:&lt;/p&gt;

&lt;h4 id=&quot;handler-接口&quot;&gt;Handler 接口&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Handler interface {
	ServeHTTP(ResponseWriter, *Request)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;该接口只定义了一个方法, 也就是说, 只要一个类型实现了这个 &lt;code class=&quot;highlighter-rouge&quot;&gt;ServeHTTP&lt;/code&gt; 方法, 我们就可以把该类型的变量直接赋值给 Handler接口, 这在后面的具体内部实现中多次出现, 很有用。&lt;/p&gt;

&lt;h4 id=&quot;servemux-结构体&quot;&gt;ServeMux 结构体&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type ServeMux struct {
	mu    sync.RWMutex
	m     map[string]muxEntry
	hosts bool // whether any patterns contain hostnames
}

type muxEntry struct {
	explicit bool
	h        Handler
	pattern  string
}

// NewServeMux allocates and returns a new ServeMux.
func NewServeMux() *ServeMux { return &amp;amp;ServeMux{m: make(map[string]muxEntry)} }

var DefaultServeMux = NewServeMux()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;ServeMux结构说明
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ServeMux
     mu    : 用于并发控制的锁
     m     : 存有muxEntry的map (key 为 pattern)
     hosts : 用于判断模式中是否包含主机名
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;muxEntry结构说明
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // 每一个 muxEntry 对应一个处理函数
 muxEntry
     explicit : 当为 true 时表明该 pattern 已注册, 防止再次有相同 pattern 进行注册
     h        : 处理函数 (如本例中的 handleRequest 函数)
     pattern  : 模式 (如本例中的 &quot;/&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;DefaultServeMux 为默认的 &lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP request multiplexer&lt;/code&gt;, 当服务端程序未指明特定的 multiplexer 时, 就会使用这个http包中声明好的 ServeMux 实例。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于 ServeMux 结构体, http包中的注释如下所示:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;ServeMux is an HTTP request multiplexer.
 It matches the URL of each incoming request against a list of registered
 patterns and calls the handler for the pattern that
 most closely matches the URL.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单来说, ServeMux这个结构体主要存储了不同 pattern 对应的逻辑处理函数 (存储于一个map中)。&lt;/p&gt;

&lt;p&gt;对于每一个请求, 将其 url 与已注册 pattern 匹配, 若匹配成功, 则调用相应的处理函数。&lt;/p&gt;

&lt;h4 id=&quot;handlerfunc类型&quot;&gt;HandlerFunc类型&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(w, r).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
	f(w, r)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;HandlerFunc类型实现了ServeHTTP方法, 因此可以赋值给前面提到的Handler接口&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 区分 HandlerFunc(类型) 和 HandleFunc(函数)&lt;/p&gt;

&lt;h4 id=&quot;serverhandler结构体&quot;&gt;serverHandler结构体&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type serverHandler struct {
    srv *Server
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;该结构体类型也实现了ServeHTTP方法, 也可以赋值给Handler接口&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;下面进行具体的源码分析:&lt;/p&gt;

&lt;h3 id=&quot;httphandlefunc&quot;&gt;http.HandleFunc&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// HandleFunc registers the handler function for the given pattern
// in the DefaultServeMux.
// The documentation for ServeMux explains how patterns are matched.
func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
	DefaultServeMux.HandleFunc(pattern, handler)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;http.HandleFunc 中,&lt;/p&gt;

&lt;p&gt;调用了ServeMux.HandleFunc方法 (receiver 为 DefaultServeMux), 传入参数 “/” 和 handleRequest 函数&lt;/p&gt;

&lt;h3 id=&quot;servemuxhandlefunc&quot;&gt;ServeMux.HandleFunc&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// HandleFunc registers the handler function for the given pattern.
func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
	mux.Handle(pattern, HandlerFunc(handler))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;ServeMux.HandleFunc中,&lt;/p&gt;

&lt;p&gt;将传入的handler (即handleRequest函数) 强制类型转换为 HandlerFunc 类型 (如前面提到的, 该类型实现了Handler接口, 可以赋值给Handler接口)&lt;/p&gt;

&lt;p&gt;然后, 调用了 ServeMux.Handle 方法 (receiver 为 DefaultServeMux), 传入参数”/”和已变为 HandlerFunc 类型的 handleRequest 函数&lt;/p&gt;

&lt;h3 id=&quot;servemuxhandle&quot;&gt;ServeMux.Handle&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Handle registers the handler for the given pattern.
// If a handler already exists for pattern, Handle panics.
func (mux *ServeMux) Handle(pattern string, handler Handler) {
	mux.mu.Lock()
	defer mux.mu.Unlock()

	if pattern == &quot;&quot; {
		panic(&quot;http: invalid pattern &quot; + pattern)
	}
	if handler == nil {
		panic(&quot;http: nil handler&quot;)
	}
	if mux.m[pattern].explicit {
		panic(&quot;http: multiple registrations for &quot; + pattern)
	}

	mux.m[pattern] = muxEntry{explicit: true, h: handler, pattern: pattern}

	if pattern[0] != '/' {
		mux.hosts = true
	}

	// Helpful behavior:
	// If pattern is /tree/, insert an implicit permanent redirect for /tree.
	// It can be overridden by an explicit registration.
	n := len(pattern)
	if n &amp;gt; 0 &amp;amp;&amp;amp; pattern[n-1] == '/' &amp;amp;&amp;amp; !mux.m[pattern[0:n-1]].explicit {
		// If pattern contains a host name, strip it and use remaining
		// path for redirect.
		path := pattern
		if pattern[0] != '/' {
			// In pattern, at least the last character is a '/', so
			// strings.Index can't be -1.
			path = pattern[strings.Index(pattern, &quot;/&quot;):]
		}
		url := &amp;amp;url.URL{Path: path}
		mux.m[pattern[0:n-1]] = muxEntry{h: RedirectHandler(url.String(), StatusMovedPermanently), pattern: pattern}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ServeMux.Handle中,&lt;/p&gt;

&lt;p&gt;前面主要进行了输入参数(pattern 和 handler)的合法性检测&lt;/p&gt;

&lt;p&gt;我们重点关注这一行代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mux.m[pattern] = muxEntry{explicit: true, h: handler, pattern: pattern}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这行代码声明并初始化了一个muxEntry结构体, 并根据其 pattern 将其放到 DefaultServeMux 的 map &lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt; 中, 实现了相应路由处理函数的注册&lt;/p&gt;

&lt;p&gt;(注: 将 explicit 设为 true 表明该 pattern 已注册, 当有相同 pattern 进行注册时, 会调用panic函数)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;至此, main中第一个关键函数调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;http.HandleFunc(&quot;/&quot;, HandleRequest)&lt;/code&gt; 就分析完毕了, 实际上就是把 pattern(“/”) 和 handler(HandleRequest) 存入 DefaultServeMux 的 map 中&lt;/p&gt;

&lt;p&gt;下面对第二个关键调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;http.ListenAndServe(&quot;:9090&quot;, nil)&lt;/code&gt; 进行分析&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;httplistenandserve&quot;&gt;http.ListenAndServe&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ListenAndServe always returns a non-nil error.
func ListenAndServe(addr string, handler Handler) error {
	server := &amp;amp;Server{Addr: addr, Handler: handler}
	return server.ListenAndServe()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;http.ListenAndServe中,&lt;/p&gt;

&lt;p&gt;首先用传入的参数 (“:9090” &amp;amp; nil) 初始化了一个Server结构体&lt;/p&gt;

&lt;p&gt;然后调用了Server.ListenAndServe方法 (receiver 为刚创建的server)&lt;/p&gt;

&lt;h3 id=&quot;serverlistenandserve&quot;&gt;Server.ListenAndServe&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ListenAndServe listens on the TCP network address srv.Addr and then
// calls Serve to handle requests on incoming connections.
// Accepted connections are configured to enable TCP keep-alives.
// If srv.Addr is blank, &quot;:http&quot; is used.
// ListenAndServe always returns a non-nil error.
func (srv *Server) ListenAndServe() error {
	addr := srv.Addr
	if addr == &quot;&quot; {
		addr = &quot;:http&quot;
	}
	ln, err := net.Listen(&quot;tcp&quot;, addr)
	if err != nil {
		return err
	}
	return srv.Serve(tcpKeepAliveListener{ln.(*net.TCPListener)})
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Server.ListenAndServe中,&lt;/p&gt;

&lt;p&gt;对给定的端口进行监听 (基于TCP协议)&lt;/p&gt;

&lt;p&gt;并调用Server.Serve函数(receiver 为之前创建的实例 server), 传入参数 ln (调用listen函数后返回的Listener接口)&lt;/p&gt;

&lt;h3 id=&quot;serverserve&quot;&gt;Server.Serve&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Serve accepts incoming connections on the Listener l, creating a
// new service goroutine for each. The service goroutines read requests and
// then call srv.Handler to reply to them.
// Serve always returns a non-nil error.
func (srv *Server) Serve(l net.Listener) error {
	defer l.Close()
	if fn := testHookServerServe; fn != nil {
		fn(srv, l)
	}
	var tempDelay time.Duration // how long to sleep on accept failure
	if err := srv.setupHTTP2(); err != nil {
		return err
	}
	for {
		rw, e := l.Accept()
		if e != nil {
			if ne, ok := e.(net.Error); ok &amp;amp;&amp;amp; ne.Temporary() {
				if tempDelay == 0 {
					tempDelay = 5 * time.Millisecond
				} else {
					tempDelay *= 2
				}
				if max := 1 * time.Second; tempDelay &amp;gt; max {
					tempDelay = max
				}
				srv.logf(&quot;http: Accept error: %v; retrying in %v&quot;, e, tempDelay)
				time.Sleep(tempDelay)
				continue
			}
			return e
		}
		tempDelay = 0
		c := srv.newConn(rw)
		c.setState(c.rwc, StateNew) // before Serve can return
		go c.serve()
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Server.Serve中,
可将上述代码简化为:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for {
    rw, e := l.Accept()
    ...
    c, err := srv.newConn(rw)
    ...
    go c.serve()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Listener 接收请求&lt;/p&gt;

&lt;p&gt;当接收到请求时, 建立新连接&lt;/p&gt;

&lt;p&gt;并用 goroutine 运行 conn.serve (receiver 为 建立新连接后返回的 Conn指针 &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;)&lt;/p&gt;

&lt;h3 id=&quot;connserve&quot;&gt;conn.serve&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Serve a new connection.
func (c *conn) serve() {
	c.remoteAddr = c.rwc.RemoteAddr().String()
	defer func() {
		if err := recover(); err != nil {
			const size = 64 &amp;lt;&amp;lt; 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			c.server.logf(&quot;http: panic serving %v: %v\n%s&quot;, c.remoteAddr, err, buf)
		}
		if !c.hijacked() {
			c.close()
			c.setState(c.rwc, StateClosed)
		}
	}()

	if tlsConn, ok := c.rwc.(*tls.Conn); ok {
		if d := c.server.ReadTimeout; d != 0 {
			c.rwc.SetReadDeadline(time.Now().Add(d))
		}
		if d := c.server.WriteTimeout; d != 0 {
			c.rwc.SetWriteDeadline(time.Now().Add(d))
		}
		if err := tlsConn.Handshake(); err != nil {
			c.server.logf(&quot;http: TLS handshake error from %s: %v&quot;, c.rwc.RemoteAddr(), err)
			return
		}
		c.tlsState = new(tls.ConnectionState)
		*c.tlsState = tlsConn.ConnectionState()
		if proto := c.tlsState.NegotiatedProtocol; validNPN(proto) {
			if fn := c.server.TLSNextProto[proto]; fn != nil {
				h := initNPNRequest{tlsConn, serverHandler{c.server}}
				fn(c.server, tlsConn, h)
			}
			return
		}
	}

	c.r = &amp;amp;connReader{r: c.rwc}
	c.bufr = newBufioReader(c.r)
	c.bufw = newBufioWriterSize(checkConnErrorWriter{c}, 4&amp;lt;&amp;lt;10)

	for {
		w, err := c.readRequest()
		if c.r.remain != c.server.initialReadLimitSize() {
			// If we read any bytes off the wire, we're active.
			c.setState(c.rwc, StateActive)
		}
		if err != nil {
			if err == errTooLarge {
				// Their HTTP client may or may not be
				// able to read this if we're
				// responding to them and hanging up
				// while they're still writing their
				// request.  Undefined behavior.
				io.WriteString(c.rwc, &quot;HTTP/1.1 431 Request Header Fields Too Large\r\nContent-Type: text/plain\r\nConnection: close\r\n\r\n431 Request Header Fields Too Large&quot;)
				c.closeWriteAndWait()
				return
			}
			if err == io.EOF {
				return // don't reply
			}
			if neterr, ok := err.(net.Error); ok &amp;amp;&amp;amp; neterr.Timeout() {
				return // don't reply
			}
			var publicErr string
			if v, ok := err.(badRequestError); ok {
				publicErr = &quot;: &quot; + string(v)
			}
			io.WriteString(c.rwc, &quot;HTTP/1.1 400 Bad Request\r\nContent-Type: text/plain\r\nConnection: close\r\n\r\n400 Bad Request&quot;+publicErr)
			return
		}

		// Expect 100 Continue support
		req := w.req
		if req.expectsContinue() {
			if req.ProtoAtLeast(1, 1) &amp;amp;&amp;amp; req.ContentLength != 0 {
				// Wrap the Body reader with one that replies on the connection
				req.Body = &amp;amp;expectContinueReader{readCloser: req.Body, resp: w}
			}
		} else if req.Header.get(&quot;Expect&quot;) != &quot;&quot; {
			w.sendExpectationFailed()
			return
		}

		// HTTP cannot have multiple simultaneous active requests.[*]
		// Until the server replies to this request, it can't read another,
		// so we might as well run the handler in this goroutine.
		// [*] Not strictly true: HTTP pipelining.  We could let them all process
		// in parallel even if their responses need to be serialized.
		serverHandler{c.server}.ServeHTTP(w, w.req)
		if c.hijacked() {
			return
		}
		w.finishRequest()
		if !w.shouldReuseConnection() {
			if w.requestBodyLimitHit || w.closedRequestBodyEarly() {
				c.closeWriteAndWait()
			}
			return
		}
		c.setState(c.rwc, StateIdle)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;类似的, 我们重点关注for循环部分并将其简化为:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for{
  w, err := c.readRequest()
  ...
  serverHandler{c.server}.ServeHTTP(w, w.req)
  ...
  w.finishRequest()
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对于同一个连接, 循环地执行读取请求, 处理请求, 完成请求三个操作&lt;/p&gt;

&lt;p&gt;对于其中三个操作, 我们重点看处理请求部分&lt;/p&gt;

&lt;p&gt;即: &lt;code class=&quot;highlighter-rouge&quot;&gt;serverHandler{c.server}.ServeHTTP(w, w.req)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;该语句调用了 serverHandler.ServeHTTP 方法&lt;/p&gt;

&lt;h3 id=&quot;serverhandlerservehttp&quot;&gt;serverHandler.ServeHTTP&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {
    handler := sh.srv.Handler
    if handler == nil {
        handler = DefaultServeMux
    }
    if req.RequestURI == &quot;*&quot; &amp;amp;&amp;amp; req.Method == &quot;OPTIONS&quot; {
        handler = globalOptionsHandler{}
    }
    handler.ServeHTTP(rw, req)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;serverHandler.ServeHTTP中,&lt;/p&gt;

&lt;p&gt;根据我们在一开始调用http.ListenAndServe函数时传入的handler参数来确定 handler (ServeMux结构体类型), 若传入为 &lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;, 则 handler 为默认的 DefaultServeMux,
然后调用 ServeMux.ServeHTTP 方法 (receiver 为handler, 本例中即为 DefaultServeMux)&lt;/p&gt;

&lt;h3 id=&quot;servemuxservehttp&quot;&gt;ServeMux.ServeHTTP&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ServeHTTP dispatches the request to the handler whose
// pattern most closely matches the request URL.
func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {
	if r.RequestURI == &quot;*&quot; {
		if r.ProtoAtLeast(1, 1) {
			w.Header().Set(&quot;Connection&quot;, &quot;close&quot;)
		}
		w.WriteHeader(StatusBadRequest)
		return
	}
	h, _ := mux.Handler(r)
	h.ServeHTTP(w, r)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ServeMux.ServeHTTP中,&lt;/p&gt;

&lt;p&gt;我们主要关注下面两行代码:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;h, _ := mux.Handler(r)
h.ServeHTTP(w, r)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;第一行代码 调用了 ServeMux.Handler 方法 (此处 receiver 为 DefaultServeMux), 传入请求 &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt;, 返回相应的逻辑处理函数 (HandlerFunc 类型)&lt;/p&gt;

&lt;p&gt;第二行代码 则是执行返回的 handler 的 ServeHTTP 方法(即 &lt;code class=&quot;highlighter-rouge&quot;&gt;HandlerFunc.ServeHTTP&lt;/code&gt;, 该方法在前面的 &lt;code class=&quot;highlighter-rouge&quot;&gt;内置结构体 &amp;amp; 类型 定义&lt;/code&gt; 那节给出, 实际上就是执行了 receiver 本身)&lt;/p&gt;

&lt;p&gt;至于 ServeMux.Handler, 其具体实现如下所示&lt;/p&gt;

&lt;h3 id=&quot;servemuxhandler&quot;&gt;ServeMux.Handler&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) {
	if r.Method != &quot;CONNECT&quot; {
		if p := cleanPath(r.URL.Path); p != r.URL.Path {
			_, pattern = mux.handler(r.Host, p)
			url := *r.URL
			url.Path = p
			return RedirectHandler(url.String(), StatusMovedPermanently), pattern
		}
	}

	return mux.handler(r.Host, r.URL.Path)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;ServeMux.Handler中,&lt;/p&gt;

&lt;p&gt;调用了 ServeMux.handler 方法(receiver 为 DefaultServeMux), 传入请求 &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; 的 主机名 &amp;amp; URL的路径部分&lt;/p&gt;

&lt;h3 id=&quot;servemuxhandler-1&quot;&gt;ServeMux.handler&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (mux *ServeMux) handler(host, path string) (h Handler, pattern string) {
    mux.mu.RLock()
    defer mux.mu.RUnlock()

    // Host-specific pattern takes precedence over generic ones
    if mux.hosts {
        h, pattern = mux.match(host + path)
    }
    if h == nil {
        h, pattern = mux.match(path)
    }
    if h == nil {
        h, pattern = NotFoundHandler(), &quot;&quot;
    }
    return
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;ServeMux.Handler中,&lt;/p&gt;

&lt;p&gt;调用 ServeMux.match 方法, 传入相应的请求路径, 返回 匹配的 handler 和 pattern&lt;/p&gt;

&lt;h3 id=&quot;servemuxmatch&quot;&gt;ServeMux.match&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (mux *ServeMux) match(path string) (h Handler, pattern string) {
	var n = 0
	for k, v := range mux.m {
		if !pathMatch(k, path) {
			continue
		}
		if h == nil || len(k) &amp;gt; n {
			n = len(k)
			h = v.h
			pattern = v.pattern
		}
	}
	return
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ServeMux.match中,&lt;/p&gt;

&lt;p&gt;遍历 receiver (此处为 DefaultServeMux) 的 map, 对于输入的路径, 找到能与之相匹配的已注册pattern, 返回 相应的 handler 和 pattern&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;最后, 重新整理一下主要的函数调用过程:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;main
├── http.HandleFunc
|   └── ServeMux.HandleFunc
|       └── ServeMux.Handle
└── http.ListenAndServe
    └── Server.ListenAndServe
        ├── net.Listen
        └── Server.Serve
            ├── Listener.Accept
            ├── Server.newConn
            └── conn.serve
                ├── conn.readRequest
                ├── serverHandler.ServeHTTP
                |   └── ServeMux.ServeHTTP
                |       ├── ServeMux.Handler
                |       |   └── ServeMux.handler
                |       |       └── ServeMux.match
                |       └── HandlerFunc.ServeHTTP
                └── response.finishRequest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;至此, 对于实现web服务器搭建部分的http源码就基本分析完啦。&lt;/p&gt;

&lt;p&gt;注: 代码高亮暂时存在问题, 等以后解决了再更新。(貌似暂不支持golang语法高亮)&lt;/p&gt;
</description>
        <pubDate>Thu, 16 Nov 2017 23:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/11/16/go-http-src-analysis/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/11/16/go-http-src-analysis/</guid>
        
        <category>go</category>
        
        <category>http</category>
        
        
      </item>
    
      <item>
        <title>Welcome to Yezh Blog</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“This is the beginning.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;Yezh 的 blog 开通啦!&lt;/p&gt;

&lt;p&gt;现在开始, 我将不定期更新我的博客。&lt;/p&gt;

&lt;p&gt;内容主要为技术帖。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;

&lt;p&gt;一开始打算直接弄一个 CSDN 博客, 但是在注册时用户名老是重复, 不重复的又不好记, 于是就暂时搁置了。&lt;/p&gt;

&lt;p&gt;后来发现 &lt;code class=&quot;highlighter-rouge&quot;&gt;Github Pages&lt;/code&gt; 可以免费托管静态内容, 了解后发现并不难, 于是就开始正式搭建我的博客啦。&lt;/p&gt;

&lt;p&gt;我采用的技术方案为: &lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt; + &lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其优点有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可直接采用 &lt;strong&gt;Markdown&lt;/strong&gt; 书写&lt;/li&gt;
  &lt;li&gt;采用 Git workflow ，&lt;strong&gt;Git Commit 即 Blog Post&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;免费无限空间 (不用自己折腾主机)&lt;/li&gt;
  &lt;li&gt;可自定义域名 (只需简单改改 DNS, 加个 CNAME 就好了)&lt;/li&gt;
  &lt;li&gt;Jekyll 自定制实现容易&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;博客搭建的过程主要参照了 &lt;a href=&quot;http://qiubaiying.top/2017/02/06/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/&quot;&gt;利用 GitHub Pages 快速搭建博客&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;致谢&quot;&gt;致谢&lt;/h2&gt;

&lt;p&gt;最后, 感谢 &lt;a href=&quot;https://github.com/huxpro&quot;&gt;Huxpro&lt;/a&gt; 提供的博客模板 和 &lt;a href=&quot;https://github.com/qiubaiying&quot;&gt;qiubaiying&lt;/a&gt; 的博客搭建教程。&lt;/p&gt;
</description>
        <pubDate>Wed, 15 Nov 2017 09:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/11/15/hello-blog/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/11/15/hello-blog/</guid>
        
        <category>blog</category>
        
        
      </item>
    
  </channel>
</rss>
